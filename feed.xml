<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.7.4">Jekyll</generator><link href="https://soonjune.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://soonjune.github.io/" rel="alternate" type="text/html" /><updated>2020-08-26T23:56:14+09:00</updated><id>https://soonjune.github.io/</id><title type="html">Seung Joon’s Blog</title><subtitle>Personal Blog of Park Seung Joon</subtitle><entry><title type="html">Pythonic Thinking(1) 파이썬 효율적으로 사용하기</title><link href="https://soonjune.github.io/Effective-Python" rel="alternate" type="text/html" title="Pythonic Thinking(1) 파이썬 효율적으로 사용하기" /><published>2020-08-26T23:30:00+09:00</published><updated>2020-08-26T23:30:00+09:00</updated><id>https://soonjune.github.io/Effective-Python</id><content type="html" xml:base="https://soonjune.github.io/Effective-Python">&lt;p&gt;유명한 Effective 시리즈의 Python 부분을 읽고 정리하고자 한다. 효율적인 코드 작성을 위한 90가지 방법 중 하루에 3가지씩 정리해보자.&lt;/p&gt;

&lt;p&gt;첫번째 챕터는 Pythonic Thinking이다. Pythonic이라는 것이 형용사로 만들어질만큼 C나 Java와는 다른 특성을 지는 것을 알 수 있다. Pythonic의 정의를 찾아보니 Stack Overflow에서는 &lt;code class=&quot;highlighter-rouge&quot;&gt;Exploiting the features of the Python language to produce code that is clear, concise and maintainable.&lt;/code&gt;이라는 설명이 나온다. 즉, 파이썬 코드의 간결하고 명확한 특성을 나타내는 말이다. Pythonic Thinking은 이러한 명확한 코드를 구현하기 위한 생각 방식이라고 볼 수 있다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;파이썬 버전을 알자
최신 버전은 Python 3.8이다(2020년 8월 기준). 커맨드 또는 터미널에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;python3 --version&lt;/code&gt; 또는 &lt;code class=&quot;highlighter-rouge&quot;&gt;python --version&lt;/code&gt;을 통해서 버전을 확인할 수 있다. 맥의 경우 python 2.7이 기본으로 설치되어 있는데 새로 Python 3을 설치해주자.&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;명령 프롬트에서 올바른 버전의 파이썬이 설치되어 있는지 확인하자.&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;PEP8 스타일 가이드를 따르자&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;PEP8 가이드에 대해 정리가 잘 된 &lt;a href=&quot;https://wayhome25.github.io/python/2017/05/04/pep8/&quot;&gt;블로그&lt;/a&gt;를 참조하자.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;공통의 스타일을 사용함으로써 협업을 용이하게 할 수 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;일관적인 스타일의 사용은 추후 자신의 코드 수정을 용이하게 한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;bytes&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;str&lt;/code&gt;의 차이를 알자.&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;bytes: 8-bit values    &lt;br /&gt;
str: Unicode cdoe points&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;헬퍼 함수(개발자의 편의를 위한 함수)를 이용해서 원하는 문자 시퀀스 타입을 리턴하도록 하자.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;bytes&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;str&lt;/code&gt; 인스턴스는 서로 연산할 수 없다 (&amp;gt;, ==, +, % 등).&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;바이너리 데이터를 읽고 쓰기 위해서는 ‘rb’, ‘wb’ 모드에서 파일을 &lt;code class=&quot;highlighter-rouge&quot;&gt;open&lt;/code&gt;한다.
    &lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'data.bin'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'wb'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\xf1\xf2\xf3\xf4\xf5&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'data.bin'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'rb'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;Unicode 데이터를 읽고 쓸 때에는 시스템의 디폴트 인코딩에 주의해라. encoding parameter를 명시적으로 전달하자. &lt;br /&gt;
아래는 윈도우의 ‘cp1252’로 인코딩된 파일을 읽는 예시.
    &lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'data.bin'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'r'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;encoding&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'cp1252) as f:&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;  data = f.read()&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;출처: Slatkin, B. (2020). Effective Python: 90 specific ways to write better Python. USA: Addison-Wesley.&lt;/em&gt;&lt;/p&gt;</content><author><name>Park Seung Joon</name></author><category term="python" /><summary type="html">유명한 Effective 시리즈의 Python 부분을 읽고 정리하고자 한다. 효율적인 코드 작성을 위한 90가지 방법 중 하루에 3가지씩 정리해보자.</summary></entry><entry><title type="html">면접 대비 - 인공지능, 기계학습 개념 복습</title><link href="https://soonjune.github.io/AI-Review" rel="alternate" type="text/html" title="면접 대비 - 인공지능, 기계학습 개념 복습" /><published>2020-08-17T23:30:00+09:00</published><updated>2020-08-17T23:30:00+09:00</updated><id>https://soonjune.github.io/AI-Review</id><content type="html" xml:base="https://soonjune.github.io/AI-Review">&lt;p&gt;면접 대비를 위해서 정리한 내용을 간단히 써보고자 한다.&lt;/p&gt;

&lt;h2 id=&quot;1-machine-learning-정의&quot;&gt;1. Machine Learning 정의&lt;/h2&gt;
&lt;h3 id=&quot;well-posed-learning-problem-by-tom-mitchell&quot;&gt;Well-posed learning problem by Tom Mitchell&lt;/h3&gt;
&lt;p&gt;경험(E)이 늘어남에 따라 특정 작업(T)를 수행하는 지표(P)의 개선이 이루어 질 때 기계가 학습한다고 정의할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;2-지도비지도-학습-강화학습&quot;&gt;2. 지도/비지도 학습, 강화학습&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;지도 학습 - 정답과 오답이 주어져서 training set을 바탕으로 정확도 높은 함수를 학습하는 것이 목표이다. 연속적인 데이터를 바탕으로 예측하는 회귀 문제나 비연속적인 데이터를 분류하는 Classification 문제가 지도 학습의 예이다.&lt;/li&gt;
  &lt;li&gt;비지도 학습 - 어떤 명시적인 정답이 주어지지 않고 데이터의 특성을 파악하는 과정이라고 할 수 있다. Clustering, Anomaly detection, association, autoencoder와 같은 문제가 해당된다.&lt;/li&gt;
  &lt;li&gt;강화학습 - Agent가 가장 reward가 높은 policy를 학습하는 학습 방법이다. 이제부터 강화학습에 대해 좀 더 알아보자.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;search-problem&quot;&gt;Search Problem&lt;/h2&gt;
&lt;p&gt;4가지 요소를 갖는다. - state space, successor function(action, cost), start sate/goal state   &lt;br /&gt;
여기서 start state에서 goal state까지 도달하게 만드는 일련의 action을 solution이라고 한다.&lt;/p&gt;
&lt;h3 id=&quot;1-uninformed-search&quot;&gt;1. Uninformed Search&lt;/h3&gt;
&lt;p&gt;어떤 그래프(State Space Graph) 또는 트리(Search Tree)를 탐색하는 문제에서 아무런 정보가 주어지지 않은 상태이다. DFS, BFS를 통해 완전탐색을 할 수 있다. 그래프는 각각의 상태가 한나의 노드로만 표현되기에 사이즈가 작다는 장점이 있고 트리는 상태가 여러번 등장하기도 하지만 goal state까지 하나의 고유한 path로 나타낼 수 있다는 장점이 있다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Uniform Cost Search - 모든 옵션까지의 비용을 계산해서 가장 비용이 작은 노드를 확장한다.(Optimal, Complete, but Slow)
    &lt;h3 id=&quot;2-informed-search&quot;&gt;2. Informed Search&lt;/h3&gt;
  &lt;/li&gt;
  &lt;li&gt;Gready Search - Heuristic function(goal에 가까운 정도를 예측하는 함수)에 따라 goal state에 가장 가깝다고 생각되는 node를 expand한다. Optimal한 solution을 보장하지 못한다.&lt;/li&gt;
  &lt;li&gt;A* Search(Best of both worlds - optimal &amp;amp; fast)&lt;/li&gt;
  &lt;li&gt;조건: Admissible(Optimistic) Heuristic - goal까지의 true cost보다 높게(비관적인) 전망을 하지 않아야 한다.   &lt;br /&gt;
똑같은 node를 두번 탐색하지 않도록 Graph Search에서는 Consistency 조건이 필요하다. 하나의 arc(간선)의 비용 예측이 실제 비용보다 작아야한다.
f = h + g
goal에 더 가까운 지점 B보다 goal에서 먼 A가 더 먼저 fringe에 들어간다는 것을 보이는 것으로 optmiality를 증명할 수 있다.
    &lt;h3 id=&quot;3-adverserial-search&quot;&gt;3. Adverserial Search&lt;/h3&gt;
  &lt;/li&gt;
  &lt;li&gt;Minimax는 deterministic &amp;amp; perfect information 게임에서 상대방이 optimal한 선택을 한다고 가정하고 상대가 나에게 가장 불리한 선택할 것을 가정한뒤 선택에 임한다. 내가 Max agent인 경우에는 상대가 선택한 최소 reward 중에서 가장 큰 것을 선택하게 되고 min agent는 그 반대로 행동할 것이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Pruning - 선택되지 않을 것들을 탐색에서 제외할 수 있다. 알파-베타 프루닝을 통해서 Max agent는 탐색과정에서 얻을 수 있는 최대 value(알파), Min agent는 탐색과정에서 얻을 수 있는 최소 value(베타)와 새로운 노드를 비교해서 탐색하게 되는 노드 수를 줄이는 과정을 거친다.   &lt;br /&gt;
Minimizer: v &amp;gt; alpha =&amp;gt; prune
Maximizer: v &amp;lt; beta =&amp;gt; prune&lt;/p&gt;

&lt;p&gt;Expectimax는 상대방이 최적의 선택을 하지 않는다고 가정하고 확률을 도입해서 expected value가 가장 큰 노드를 선택한다.&lt;/p&gt;
&lt;h3 id=&quot;4-markov-decision-processes&quot;&gt;4. &lt;a href=&quot;https://en.wikipedia.org/wiki/Markov_decision_process&quot;&gt;Markov Decision Processes&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;다음 state는 오직 현재 state에 의해서만 영향을 받는다(Simplified version of the world). 즉, 미래와 과거가 독립이라는 것을 가정한다. 보상 R(s, a, s’) / Transition function T(s, a, s’) = P(s’|s, a)&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Value Iteration
&lt;img src=&quot;https://wikimedia.org/api/rest_v1/media/math/render/svg/642146ac65c7d64f99f1a77ffdff3397b555068e&quot; /&gt;
Complexity - O(S^2A)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Bellman_equation&quot;&gt;Bellman Equations&lt;/a&gt;: a Bellman equation is a recursion for expected rewards.
    &lt;h3 id=&quot;value-iteration의-문제점&quot;&gt;Value Iteration의 문제점&lt;/h3&gt;
    &lt;p&gt;V function에는 optimal action이 포함되지 않음. 수렴하는데 오래 걸림. =&amp;gt; Policy Iteration: action을 track하지 않아도 돼서 시간이 적게 걸림(Value iteration 둘다 one-step lookahead 개념 활용) &lt;br /&gt;
Q value를 활용하면 action을 선택하기 쉬워짐&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;regret = u(possible action) - u(action taken)
it converges to 0 if the strategy is good enough&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;mdp-아닌-경우model-free-문제점&quot;&gt;MDP 아닌 경우(Model-free) 문제점&lt;/h3&gt;
&lt;p&gt;In reinforcement learning (RL), a model-free algorithm (as opposed to a model-based one) is an algorithm which does not use the transition probability distribution (and the reward function) associated with the Markov decision process (MDP)   &lt;br /&gt;
R, T를 모름&lt;/p&gt;
&lt;h4 id=&quot;해결책-q-learning&quot;&gt;해결책: Q-Learning&lt;/h4&gt;
&lt;p&gt;Q-values를 활용: action을 선택하고 그에 따른 reward에 맞춰서 Q-value를 업데이트 해줌.
&lt;img src=&quot;https://wikimedia.org/api/rest_v1/media/math/render/svg/678cb558a9d59c33ef4810c9618baf34a9577686&quot; /&gt;&lt;/p&gt;
&lt;h3 id=&quot;q-learning의-문제점&quot;&gt;Q-Learning의 문제점&lt;/h3&gt;
&lt;p&gt;비슷한 노드끼리 서로 다르게 보기 때문에 탐색과정을 일일이 거쳐야 한다는 단점. 따라서 feature를 이용해서 state를 일반화해주는 것이 가능하다. =&amp;gt; Feature-Based Representation &amp;amp; Approximate Q-Learning&lt;/p&gt;

&lt;h3 id=&quot;5-naive-bayes-및-확률-기초-개념-정리&quot;&gt;5. Naive Bayes 및 확률 기초 개념 정리&lt;/h3&gt;
&lt;p&gt;1) random variable - 확률적인 과정에 따라 값이 결정되는 변수(오메가 -&amp;gt; E로의 mapping)  &lt;br /&gt;
2) 조건부 확률 - 주어진 사건이 일어났다는 가정 하에 다른 한 사건이 일어날 확률을 뜻한다.  &lt;br /&gt;
3) &lt;a href=&quot;https://en.wikipedia.org/wiki/Chain_rule_(probability)&quot;&gt;Chain rule&lt;/a&gt;  &lt;br /&gt;
4) &lt;a href=&quot;https://en.wikipedia.org/wiki/Bayes%27_theorem&quot;&gt;Bayes Theorem&lt;/a&gt;   &lt;br /&gt;
5) &lt;a href=&quot;https://en.wikipedia.org/wiki/Maximum_likelihood_estimation&quot;&gt;MLE&lt;/a&gt;    &lt;br /&gt;
6) &lt;a href=&quot;https://en.wikipedia.org/wiki/Maximum_a_posteriori_estimation&quot;&gt;MAP&lt;/a&gt;    &lt;br /&gt;
7) 조건부 독립 - p(a|b,c)=p(a|c), 즉 b, c가 있거나 없거나 a의 확률에 영향을 미치지 않는다.
8) Naive Bayes- 조건부 독립을 가정하면 c의 prior와 c와 다른 사건의 조건부 확률의 곱 또는 log합으로 나타낼 수 있다.   &lt;br /&gt;
장점은 단순하고 빠르다는 것이 있으나 independent하지 않을 경우 bias 문제에 빠질 수 있으며 pattern을 모델링 할 수 없다는 문제가 있다. 따라서 정확도도 낮은 편이다.&lt;/p&gt;

&lt;h3 id=&quot;6-기계학습-정리&quot;&gt;6. 기계학습 정리&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Overfitting 방지를 위한 regularization term 추가&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Backpropagation&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;A support vector machine (SVM) is a supervised machine learning model that uses classification algorithms for two-group classification problems. After giving an SVM model sets of labeled training data for each category, they’re able to categorize new text.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Kernel Trick - Kernel function(similarity function)은 높은 차원의 내적을 의미한다. K(x_i,x_j)로 구성된 행렬은 positive semi-definite matrix여야 하며 대칭행렬(symetric matrix)이어야 합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;PCA - eigenvalue decomposition of covariance matrices&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;7-딥러닝&quot;&gt;7. 딥러닝&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;CNN - In deep learning, a convolutional neural network (CNN, or ConvNet) is a class of deep neural networks, most commonly applied to analyzing visual imagery.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;RNN - A recurrent neural network (RNN) is a class of artificial neural networks where connections between nodes form a directed graph along a temporal sequence.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>Park Seung Joon</name></author><category term="interview" /><summary type="html">면접 대비를 위해서 정리한 내용을 간단히 써보고자 한다.</summary></entry><entry><title type="html">IO speed - 입출력 속도 비교 및 자바 입출력 방법</title><link href="https://soonjune.github.io/IO" rel="alternate" type="text/html" title="IO speed - 입출력 속도 비교 및 자바 입출력 방법" /><published>2020-08-12T23:30:00+09:00</published><updated>2020-08-12T23:30:00+09:00</updated><id>https://soonjune.github.io/IO</id><content type="html" xml:base="https://soonjune.github.io/IO">&lt;p&gt;오늘은 간단히 입출력 방법에 대해 정리해보고자 한다.&lt;/p&gt;

&lt;p&gt;알고리즘 문제를 풀다보면 입출력으로 인해 시간 초과가 발생하는 경우가 있다.   &lt;br /&gt;
백준 사이트에서 입출력 속도를 비교한 것을 보고 어떤 입출력을 사용하는 것이 속도 측면에서 나은지 살펴보자.  &lt;br /&gt;
&lt;a href=&quot;https://www.acmicpc.net/blog/view/56&quot;&gt;입력 속도 비교&lt;/a&gt; / &lt;a href=&quot;https://www.acmicpc.net/blog/view/57&quot;&gt;출력 속도 비교&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;입력&quot;&gt;입력&lt;/h3&gt;
&lt;p&gt;입력은 자바 기준으로 Scanner보다 BufferedReader와 Integer.parseInt를 사용하는게 약 7배 빠른 것을 알 수 있다.  &lt;br /&gt;
문제 풀이를 위한 한 줄 라인 입력은 아래와 같이 받을 수 있다.&lt;/p&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;BufferedReader&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;br&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BufferedReader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inputStreamReader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;in&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 한 줄에 integer input 하나인 경우&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;input&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;parseInt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;br&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;readLine&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 한 줄에 여러 input이 공백을 구분자로 두고 있는 경우&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;StringTokenizer&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;st&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;StringTokenizer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;br&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;readLine&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;number1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;parseInt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;st&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;nextToken&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;출력&quot;&gt;출력&lt;/h3&gt;
&lt;p&gt;출력은 BufferedWriter를 쓰는것이 System.out.println(sb)을 쓰는 것보다 빠르나 차이가 미미하기 때문에 조금 더 편리한 System.out.println(sb)를 사용하는게 좋겠다.&lt;/p&gt;

&lt;h3 id=&quot;c의-경우&quot;&gt;C++의 경우&lt;/h3&gt;
&lt;p&gt;C++은 출력에서 cout « i « endl을 사용할 경우 시간 초과가 날 수 있다. &lt;code class=&quot;highlighter-rouge&quot;&gt;endl&lt;/code&gt;대신 &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;\n&quot;&lt;/code&gt;을 이용하자.    &lt;br /&gt;
C++에서 빠른 입출력을 원할 경우 C 표준 입출력을 동기화하는 &lt;code class=&quot;highlighter-rouge&quot;&gt;ios_bas::sync_with_stdio(false);&lt;/code&gt; 설정을 해주고 &lt;code class=&quot;highlighter-rouge&quot;&gt;cin.tie(null);&lt;/code&gt;을 통해 cin과 cout을 분리해준다. 물론 그냥 C의 표준입출력 scanf/printf를 사용해도 된다.&lt;/p&gt;</content><author><name>Park Seung Joon</name></author><category term="algorithm" /><category term="java" /><summary type="html">오늘은 간단히 입출력 방법에 대해 정리해보고자 한다.</summary></entry><entry><title type="html">2. Matrix Algebra (2)</title><link href="https://soonjune.github.io/Matrix-Algebra-1" rel="alternate" type="text/html" title="2. Matrix Algebra (2)" /><published>2020-08-11T22:00:00+09:00</published><updated>2020-08-11T22:00:00+09:00</updated><id>https://soonjune.github.io/Matrix-Algebra-1</id><content type="html" xml:base="https://soonjune.github.io/Matrix-Algebra-1">&lt;p&gt;선형대수 공부 3일차 - 행렬에 대해 알아보자&lt;/p&gt;

&lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML&quot;&gt;
&lt;/script&gt;

&lt;h2 id=&quot;21-matrix-operations&quot;&gt;2.1 Matrix Operations&lt;/h2&gt;
&lt;h3 id=&quot;theorem-1&quot;&gt;Theorem 1&lt;/h3&gt;
&lt;p&gt;덧셈, 뺄셈, scalar multiple은 교환, 결합, 분배 법칙이 성립한다.&lt;/p&gt;

&lt;p&gt;행렬의 곱셈은 조금 다른데, linear transformation, function으로 이해할 수 있다.  &lt;br /&gt;
따라서 곱할 수록 span을 작아진다. 즉, span(A)가 span(AB)를 포함한다.&lt;/p&gt;
&lt;h3 id=&quot;theorem-2&quot;&gt;Theorem 2&lt;/h3&gt;
&lt;p&gt;곱셈은 결합법칙, 오른쪽/왼쪽 분배 법칙이 성립하나 교환법칙은 성립하지 않는다. 즉, AB와 BA는 같지 않을 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Powers of a Matrix  &lt;br /&gt;
A가 &lt;script type=&quot;math/tex&quot;&gt;nXn&lt;/script&gt; 행렬이라면 &lt;script type=&quot;math/tex&quot;&gt;A^n&lt;/script&gt;과 같이 행렬의 거듭제곱을 정의할 수 있다. &lt;script type=&quot;math/tex&quot;&gt;A^0 = I&lt;/script&gt;로 정의한다.&lt;/li&gt;
  &lt;li&gt;Transpose  &lt;br /&gt;
행렬의 열과 행을 뒤바꾼 것이라 보면 된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;a. &lt;script type=&quot;math/tex&quot;&gt;(A^T)^T = A&lt;/script&gt;    &lt;br /&gt;
b. &lt;script type=&quot;math/tex&quot;&gt;(A + B)^T = A^T + B^T&lt;/script&gt;   &lt;br /&gt;
c. For any scalar &lt;script type=&quot;math/tex&quot;&gt;r, (rA)^T = rA^T&lt;/script&gt;   &lt;br /&gt;
d. &lt;script type=&quot;math/tex&quot;&gt;(AB)^T = B^TA^T&lt;/script&gt;&lt;/p&gt;

&lt;h2 id=&quot;22-the-inverse-of-a-matrix&quot;&gt;2.2 The Inverse of a Matrix&lt;/h2&gt;
&lt;h3 id=&quot;theorem-4&quot;&gt;Theorem 4&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Invertible_matrix#Inversion_of_2_%C3%97_2_matrices&quot;&gt;2X2 행렬의 역행렬 공식&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;theorem-5&quot;&gt;Theorem 5&lt;/h3&gt;
&lt;p&gt;Ax = b이고 A가 역행렬이 존재하면 하나의 유일해 &lt;script type=&quot;math/tex&quot;&gt;x=A^{-1}b&lt;/script&gt;를 지닌다.&lt;/p&gt;

&lt;p&gt;참고) at least 1 solution &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
&lt;=&gt; %]]&gt;&lt;/script&gt; no free variable&lt;/p&gt;
&lt;h3 id=&quot;theorem-6&quot;&gt;Theorem 6&lt;/h3&gt;
&lt;p&gt;a. &lt;script type=&quot;math/tex&quot;&gt;(A^{-1})^{-1} = A&lt;/script&gt;   &lt;br /&gt;
b. &lt;script type=&quot;math/tex&quot;&gt;(AB)^{-1} = B^{-1}A{-1}&lt;/script&gt;   &lt;br /&gt;
c. &lt;script type=&quot;math/tex&quot;&gt;(A^T)^{-1} = (A^{-1})^T&lt;/script&gt;&lt;/p&gt;

&lt;h3 id=&quot;theorem-7&quot;&gt;Theorem 7&lt;/h3&gt;
&lt;p&gt;nXn 행렬이 &lt;script type=&quot;math/tex&quot;&gt;I_n&lt;/script&gt;과 row equivalent, 즉 echelon row reduction을 통해 &lt;script type=&quot;math/tex&quot;&gt;I&lt;/script&gt;로 만들 수 있다면 역행렬이 존재한다.  &lt;br /&gt;
&lt;script type=&quot;math/tex&quot;&gt;[A|I]&lt;/script&gt; -&amp;gt; &lt;script type=&quot;math/tex&quot;&gt;[I|C]&lt;/script&gt;로 row reduction을 거치면 C가 역행렬이다.&lt;/p&gt;

&lt;h2 id=&quot;23-characterizations-of-invertible-matrices&quot;&gt;2.3 Characterizations of Invertible Matrices&lt;/h2&gt;
&lt;h3 id=&quot;theorem-8&quot;&gt;Theorem 8&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/YUK4bQv.png&quot; align=&quot;center&quot; sytle=&quot;height: 100px;&quot; /&gt;&lt;/p&gt;
&lt;div&gt;
&lt;img src=&quot;https://i.imgur.com/ulOSO1I.png&quot; align=&quot;left&quot; /&gt;
&lt;img src=&quot;https://i.imgur.com/AwTwn4T.png&quot; align=&quot;right&quot; /&gt;
&lt;/div&gt;
&lt;p&gt;위와 같은 조건을 하나만 만족해도 역행렬이 존재하고 하나만 위배해도 역행렬이 존재하지 않는다. 마치 고리와 같이 상호 연결되어 있고 증명과정도 하나 하나 연결하면서 확인할 수 있다.&lt;/p&gt;</content><author><name>Park Seung Joon</name></author><category term="linear-algebra" /><category term="math" /><summary type="html">선형대수 공부 3일차 - 행렬에 대해 알아보자</summary></entry><entry><title type="html">자바 훑어보기: Run-through of Java Programming Language</title><link href="https://soonjune.github.io/Run-through-of-Java" rel="alternate" type="text/html" title="자바 훑어보기: Run-through of Java Programming Language" /><published>2020-08-10T20:00:00+09:00</published><updated>2020-08-10T20:00:00+09:00</updated><id>https://soonjune.github.io/Run-through-of-Java</id><content type="html" xml:base="https://soonjune.github.io/Run-through-of-Java">&lt;p&gt;삼성 SDS 대학생 알고리즘 특강이 시작됐다. 1주일간은 자바, 1주일 간은 C++로 배운다고 한다. 자바를 거의 안 다뤄서 Codecademy에서 자바 부분을 쭉 훑었다. 주요 내용을 정리해보고자 한다.&lt;/p&gt;

&lt;h2 id=&quot;i-introduction&quot;&gt;I. Introduction&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Class - a single concept
클래스는 객체 지향 언어에서 많이 등장하는 개념이다. 자바는 프로그램 파일명과 동일한 최소 하나의 클래스를 지녀야 한다(예: Person.java - Person 클라스). 클래스는 주로 대문자로 시작한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;main() Method
모든 자바 프로그램은 아래와 같이 main() method를 포함해야 한다.
    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Person&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Hello, world!&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;ul&gt;
      &lt;li&gt;Print Line
System.out.println()을 이용한다.  &lt;br /&gt;
Eclipse IDE에서는 &lt;code&gt;syso&lt;/code&gt;를 타입한 뒤 &lt;kbd&gt;CTRL&lt;/kbd&gt;+&lt;kbd&gt;Space&lt;/kbd&gt;를 누르면 자동 완성된다.&lt;/li&gt;
      &lt;li&gt;Comments&lt;/li&gt;
    &lt;/ul&gt;
    &lt;ul&gt;
      &lt;li&gt;Single line: &lt;code&gt;//&lt;/code&gt;&lt;/li&gt;
      &lt;li&gt;Multi-line: &lt;code&gt;/*&lt;/code&gt;   &lt;code&gt;*/&lt;/code&gt;
      * ; - 코드는 &lt;code&gt;;&lt;/code&gt;로 끝나야 한다;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Compilation(javac 명령어)
프로그램을 컴파일하면 각각의 클래스들이 &lt;b&gt;.class&lt;/b&gt; 파일로 변환된다. 변환된 java byte code는 JVM에 의해 실행된다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;ii-variables&quot;&gt;II. Variables&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Primitive Data Types
&lt;code&gt;int&lt;/code&gt;, &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;boolean&lt;/code&gt;, byte, long, short, &lt;code&gt;double&lt;/code&gt;, float, null&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;String - use &lt;code&gt;&quot; &quot;&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;String끼리 같은지 비교는 &lt;code&gt;.equals()&lt;/code&gt; 사용&lt;/li&gt;
      &lt;li&gt;Concatenation: + 사용 =&amp;gt; new를 사용하기 때문에 매우 느리다. 따라서 List&lt;character&gt;를 사용해서 넣다 빼거나 StringBuilder를 사용하여 효율성을 높인다.&lt;/character&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Statice Typing - 변수 선언 type과 value가 다를 경우 bug 발생&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;iii-기타-빠르게-정리&quot;&gt;III. 기타 빠르게 정리&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Array(정적인 배열) / ArrayList(동적 할당 - add()와 remove() 사용)&lt;/li&gt;
  &lt;li&gt;Loop
    &lt;ul&gt;
      &lt;li&gt;for와 for-each    &lt;br /&gt;
  for는 C와 유사하고 for-each는 아래와 같이 수행&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// array of numbers&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numbers&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// for-each loop that prints each number in numbers&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// int num is the handle while numbers is the source array&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numbers&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;  
	&lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;String Methods
    &lt;ul&gt;
      &lt;li&gt;length() - 길이&lt;/li&gt;
      &lt;li&gt;concat() - 두 String 연결&lt;/li&gt;
      &lt;li&gt;equals() - 앞에서 설명. true/false 반환&lt;/li&gt;
      &lt;li&gt;indexOf() - 특정 substring의 시작 index를 반환한다. 없을 경우 -1 반환.&lt;/li&gt;
      &lt;li&gt;charAt(int index) - String의 index번째(0부터 시작) character를 반환한다. index는 0부터 length-1까지.&lt;/li&gt;
      &lt;li&gt;toUpperCase() / toLowerCase() - String의 character를 모두 대문자 / 소문자로 바꾼 값을 반환한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;클래스 상속(Inheritance) - parent class / child class
    &lt;ul&gt;
      &lt;li&gt;child class는 extends로 정의 / super로 child의 속성 override&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;다형성(Polymorphism) - 하나의 메소드나 클래스가 있을 때 이것들이 다양한 방법으로 동작하는 것(아래 예시 코드 참조)
    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Parent class&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Animal&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;greeting&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;The animal greets you.&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// Child class&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Cat&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Animal&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;greeting&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;The cat meows.&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MainClass&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Animal&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;animal1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Animal&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// Animal object&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Animal&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cat1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Cat&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// Cat object&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;animal1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;greeting&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// prints &quot;The animal greets you.&quot;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;cat1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;greeting&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// prints &quot;The cat meows.&quot;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;Eclipse IDE 기능     &lt;br /&gt;
  클래스 내부에서 &lt;kbd&gt;Alt&lt;/kbd&gt;+&lt;kbd&gt;Shift&lt;/kbd&gt;+&lt;kbd&gt;S&lt;/kbd&gt;를 눌러서 생성자 또는 출력 toString() 코드를 바로 생성할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://codecademy-content.s3.amazonaws.com/courses/learn-java/revised-2019/access-modifiers-chart.png&quot; align=&quot;left&quot; style=&quot;width: 600px; height: 300px; padding: 0; margin: 0;&quot; /&gt;
&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;비교 및 sort 방법
    &lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CustomClass&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;list&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ArrayList&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 정의대로 정렬&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Collections&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;sort&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);=&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Collections&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;sort&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Comparator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CustomClass&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;{&lt;/span&gt;
  &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;compare&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CustomClass&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;o1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CustomClass&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;o2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// 임의의 기준 설정&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;});&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;CustomClass&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Comparable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CustomClass&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;nd&quot;&gt;@Override&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;compareTo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CustomClass&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arg0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// -1: 원하는 순서, 0: 둘이 같다, 1:원하지 않는 순서 -&amp;gt; swap&lt;/span&gt;
      &lt;span class=&quot;c1&quot;&gt;// a에 대해 오름차순으로 정렬 &lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arg0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
          &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arg0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;c1&quot;&gt;// 둘이 같은 경우 b에 대해 내림차순 정렬&lt;/span&gt;
          &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arg0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
              &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
          &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arg0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
              &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
          &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
              &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
          &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>Park Seung Joon</name></author><category term="java" /><category term="algorithm" /><summary type="html">삼성 SDS 대학생 알고리즘 특강이 시작됐다. 1주일간은 자바, 1주일 간은 C++로 배운다고 한다. 자바를 거의 안 다뤄서 Codecademy에서 자바 부분을 쭉 훑었다. 주요 내용을 정리해보고자 한다.</summary></entry><entry><title type="html">1. Linear Equations in Linear Algebra (2)</title><link href="https://soonjune.github.io/Linear-Equations-in-Linear-Algebra-2" rel="alternate" type="text/html" title="1. Linear Equations in Linear Algebra (2)" /><published>2020-08-09T21:00:00+09:00</published><updated>2020-08-09T21:00:00+09:00</updated><id>https://soonjune.github.io/Linear-Equations-in-Linear-Algebra-2</id><content type="html" xml:base="https://soonjune.github.io/Linear-Equations-in-Linear-Algebra-2">&lt;p&gt;선형대수 공부 2일차 - 오늘 배운 내용을 간단히 정리해보자&lt;/p&gt;

&lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML&quot;&gt;
&lt;/script&gt;

&lt;h2 id=&quot;15-solution-sets-of-linear-systems&quot;&gt;1.5 Solution Sets of Linear Systems&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;homogeneous: A linear equation is called homogeneous if its constant term is zero. Such an equation has the form&lt;/li&gt;
&lt;/ul&gt;
&lt;p style=&quot;text-align: center; margin: 0; padding: 0;&quot;&gt; $$a_1x_1 + a_2x_2 + ... + a_nx_n = 0$$ &lt;/p&gt;
&lt;p&gt;where &lt;script type=&quot;math/tex&quot;&gt;a_1, a_2, . . . , a_n&lt;/script&gt; are constants and &lt;script type=&quot;math/tex&quot;&gt;x_1, x_2, . . . , x_n&lt;/script&gt; are variables.
A homogeneous linear system is a linear system whose equations are all homogeneous. For example,&lt;/p&gt;
&lt;p style=&quot;text-align: center; margin: 0; padding: 0;&quot;&gt;
$$3x_1 − 9x_2 − 9x_3 − 6x_4 = 0$$
$$2x_1 − 8x_2 − 6x_3 + 2x_4 = 0$$
$$−2x_1 + 3x_2 + 8x_3 + 7x_4 = 0$$
&lt;/p&gt;

&lt;p&gt;is a homogeneous linear system.[1]&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;즉, 행렬을 사용해서 Ax = 0 꼴로 쓸 수 있으면 최소 하나의 해를 x가 영벡터인 최소 하나의 해를 가지며 이를 trivial solution이라 한다.  &lt;br /&gt;
non-trivial한 해를 갖기 위해서는 방정식이 최소 하나의 free variable을 가져야한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;16-applications-of-linear-systems&quot;&gt;1.6 Applications of Linear Systems&lt;/h2&gt;
&lt;p&gt;경제, network flow 등 다양하게 활용이 가능하다.&lt;/p&gt;

&lt;h2 id=&quot;17-linear-indepence&quot;&gt;1.7 Linear Indepence&lt;/h2&gt;
&lt;p&gt;선형 독립이라는 말이 나오며 앞서 본 방정식이 trivial solution을 가질 때 독립이라 한다.
벡터의 해가 되는 계수들이 모두 0이어야 하며 그렇지 않은 경우가 하나라도 있으면 linearly dependent하다.&lt;/p&gt;
&lt;h3 id=&quot;theorem-7-characterization-of-linearly-dependent-sets&quot;&gt;Theorem 7: Characterization of Linearly Dependent Sets&lt;/h3&gt;
&lt;p&gt;집합 S에 속한 벡터들 중 하나라도 다른 벡터의 선형 결합으로 표현할 수 있다면 linearly dependent하다.  &lt;br /&gt;
벡터를 하나씩 추가해 가면서 linearly dependent한지 여부를 확인할 수 있다. &lt;br /&gt;
추가된 벡터를 앞선 벡터들의 linear combination으로 표현할 수 있는지 확인하면 된다.&lt;/p&gt;
&lt;h3 id=&quot;theorem-8&quot;&gt;Theorem 8&lt;/h3&gt;
&lt;p&gt;If a set contains more vectors than there are entries in each vector, then the set is linearly dependent. That is, any set &lt;script type=&quot;math/tex&quot;&gt;{v_1,...,v_p}&lt;/script&gt; in &lt;script type=&quot;math/tex&quot;&gt;R^n&lt;/script&gt; is linearly dependent if p &amp;gt; n.
즉 행렬의 열의 개수가 행의 개수보다 많다면 linearly dependent하다고 할 수 있다.  &lt;br /&gt;
그 반대 p &amp;lt; n인 경우는 상황에 따라 다르기 때문에 일반화할 수 없다.&lt;/p&gt;
&lt;h3 id=&quot;theorem-9&quot;&gt;Theorem 9&lt;/h3&gt;
&lt;p&gt;If a set S D &lt;script type=&quot;math/tex&quot;&gt;{v_1,..., v_p}&lt;/script&gt; in &lt;script type=&quot;math/tex&quot;&gt;R^n&lt;/script&gt; contains the zero vector, then the set is linearly dependent.   &lt;br /&gt;
Zero vector가 존재하면 linearly dependent하다.&lt;/p&gt;

&lt;h2 id=&quot;18-introduction-to-linear-transformations&quot;&gt;1.8 Introduction to Linear Transformations&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_map&quot;&gt;transformation&lt;/a&gt;은 function, mapping과 같은 말이다.
&lt;script type=&quot;math/tex&quot;&gt;T: R^n -&gt; R^m&lt;/script&gt;인 linear transformation에 대하여&lt;/li&gt;
  &lt;li&gt;domain(정의역) - &lt;script type=&quot;math/tex&quot;&gt;R^n&lt;/script&gt;&lt;/li&gt;
  &lt;li&gt;codomain(공역) - &lt;script type=&quot;math/tex&quot;&gt;R^m&lt;/script&gt;&lt;/li&gt;
  &lt;li&gt;range(치역) / image - T(x)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;로 정의한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Linear Transformation은 아래 두 조건을 만족해야 한다.  &lt;br /&gt;
i. T(u+v) = T(u) + T(v)    &lt;br /&gt;
ii. T(cu) = cT(u) for all scalars c   &lt;br /&gt;
위 조건으로부터 T(0) = 0이 유도된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;오늘 정리로 챕터1을 마쳤다. 중간고사도 여기까지가 범위인 것 같다. 이틀만에 중간고사 범위까지 공부해서 기분이 좋다(?).&lt;/p&gt;

&lt;p&gt;[1] 출처: http://faculty.bard.edu/~belk/math213f15/Notes10.pdf&lt;/p&gt;</content><author><name>Park Seung Joon</name></author><category term="linear-algebra" /><category term="math" /><summary type="html">선형대수 공부 2일차 - 오늘 배운 내용을 간단히 정리해보자</summary></entry><entry><title type="html">1. Linear Equations in Linear Algebra (1)</title><link href="https://soonjune.github.io/Linear-Equations-in-Linear-Algebra-1" rel="alternate" type="text/html" title="1. Linear Equations in Linear Algebra (1)" /><published>2020-08-08T22:00:00+09:00</published><updated>2020-08-08T22:00:00+09:00</updated><id>https://soonjune.github.io/Linear-Equations-in-Linear-Algebra-1</id><content type="html" xml:base="https://soonjune.github.io/Linear-Equations-in-Linear-Algebra-1">&lt;p&gt;오늘 선형대수 공부를 시작했다. 자료는 고려대에 계시다가 현재는 KAIST AI 대학원으로 가신 주재걸 교수님의 &lt;a href=&quot;https://www.youtube.com/watch?v=3bTr91fLHOg&amp;amp;list=PLep-kTP3NkcOBWLIfjMYymsdagnGi3XS6&quot;&gt;강의&lt;/a&gt;와 수업에 사용한 &lt;a href=&quot;https://www.amazon.com/Linear-Algebra-Its-Applications-5th/dp/032198238X&quot;&gt;교과서&lt;/a&gt;를 참고했다.
간단히 오늘 배운 내용을 정리해보자.&lt;/p&gt;

&lt;p&gt;오늘은 간단한 개요 정도였다. 요즘 교육과정에서는 행렬이 빠졌다고 하는데 구7차 교육과정에서 처음으로 등장하는 것이 행렬이었던 것 같다. 그러면 섹션별로 간단한 개념만 짚고 넘어가자.&lt;/p&gt;

&lt;h2 id=&quot;11-systems-of-linear-equations&quot;&gt;1.1 Systems of Linear Equations&lt;/h2&gt;
&lt;p&gt;1) &lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_equation&quot;&gt;linear equation의 정의&lt;/a&gt; &lt;br /&gt;
=&amp;gt; 이러한 linear equation(s)의 집합을 &lt;a href=&quot;https://en.wikipedia.org/wiki/System_of_linear_equations&quot;&gt;systems of linear equations&lt;/a&gt; 라 한다.   &lt;br /&gt;
2) &lt;a href=&quot;https://en.wikipedia.org/wiki/Consistent_and_inconsistent_equations&quot;&gt;consistent&lt;/a&gt; - 하나 이상의 해가 존재하는 경우 / 그 반대로 해가 없는 경우는 inconsistent   &lt;br /&gt;
3) 선형방정식을 행렬로 나타낼 수 있다. (coefficient matrix, augmented matrix)   &lt;br /&gt;
4) linear system을 푸는 가장 기본적인 방법은 triangular form으로 만들어 주는 것이다. 이때 아래의 3가지 기본 row operation을 사용한다.&lt;br /&gt;
=&amp;gt; Replacement, Interchange, Scaling &lt;br /&gt;
세가지 row operation을 통해 만들 수 있는 행렬들은 row equivalent하다고 표현한다.&lt;/p&gt;

&lt;h2 id=&quot;12-row-reduction-and-echelon-forms&quot;&gt;1.2 Row Reduction and Echelon Forms&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://wikimedia.org/api/rest_v1/media/math/render/svg/3743aca294b2e5346c167819fd9ee0bcb79ef22c&quot; align=&quot;left&quot; /&gt;    
&lt;/p&gt;

&lt;p&gt;위와 같은 모양을 지닌 행렬의 형태를 &lt;a href=&quot;https://en.wikipedia.org/wiki/Row_echelon_form&quot;&gt;echelon form&lt;/a&gt; 이라고 한다.  &lt;br /&gt;
여기서 각 행의 맨 앞의 0이 아닌 수를 leading entry라고 한다. (여기서는 1, 2, 1)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://wikimedia.org/api/rest_v1/media/math/render/svg/0cbe2a26712d3e37787d46b087e97748740b553e&quot; align=&quot;left&quot; /&gt;
&lt;/p&gt;
&lt;p&gt;위와 같이 leading entry가 1이고 leading entry 밑뿐만 아니라 위의 원소들도 0이면 reduced echelon form이라고 부른다.&lt;/p&gt;

&lt;h3 id=&quot;theorem-1-uniqueness-of-the-reduced-echelon-form&quot;&gt;Theorem 1: Uniqueness of the Reduced Echelon Form&lt;/h3&gt;
&lt;p&gt;우선, 모든 행렬은 (reduced) echelon form으로 변환할 수 있다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Echelon form인 행렬의 leading entry를 pivot position이라고 한다.  &lt;br /&gt;
각 행에 pivot position이 존재하느냐의 여부에 따라이 해당 열이 basic variable인지 free variable인지 결정된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;theorem-2-existence-and-uniqueness-theorem&quot;&gt;Theorem 2: Existence and Uniqueness Theorem&lt;/h3&gt;
&lt;p&gt;Echelon form의 행렬에서 [0, …, b] 꼴로 나오는 행(b는 0이 아닌 실수)이 존재하면 해가 없다.&lt;/p&gt;

&lt;h2 id=&quot;13-vector-equations&quot;&gt;1.3 Vector Equations&lt;/h2&gt;
&lt;p&gt;교환 법칙, 결합 법칙 등이 성립한다. &lt;br /&gt;
span의 개념을 확인하자 - set of all possible linear combinations   &lt;br /&gt;
&lt;a href=&quot;https://www.youtube.com/watch?v=k7RM-ot2NWY&quot;&gt;등장개념 영상&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;14-the-matrix-equation-ax--b&quot;&gt;1.4 The Matrix Equation Ax = b&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/1mgvPjG.png&quot; alt=&quot;theorem 3 and 4&quot; /&gt;&lt;/p&gt;

&lt;p&gt;공부를 하면서 최근에 본 물리학자인 &lt;a href=&quot;https://youtu.be/8n80LX2LGjY?t=90&quot;&gt;파인만의 영상&lt;/a&gt;이 떠올랐다. 선형대수도 직관이 더해지면 더 오래 기억하고 의미있게 활용할 수 있을 것이다. 단순히 해를 구하는 것은 컴퓨터가 더 잘하니 숨겨진 의의를 찾는데 집중하면 좋을 것 같다.&lt;/p&gt;</content><author><name>Park Seung Joon</name></author><category term="linear-algebra" /><category term="math" /><summary type="html">오늘 선형대수 공부를 시작했다. 자료는 고려대에 계시다가 현재는 KAIST AI 대학원으로 가신 주재걸 교수님의 강의와 수업에 사용한 교과서를 참고했다. 간단히 오늘 배운 내용을 정리해보자.</summary></entry><entry><title type="html">SMART한 목표 설정하기</title><link href="https://soonjune.github.io/SMART-goal" rel="alternate" type="text/html" title="SMART한 목표 설정하기" /><published>2020-08-07T20:00:00+09:00</published><updated>2020-08-07T20:00:00+09:00</updated><id>https://soonjune.github.io/SMART-goal</id><content type="html" xml:base="https://soonjune.github.io/SMART-goal">&lt;p&gt;우연히 마이크로소프트에서 하는 &lt;a href=&quot;https://www.insidesherpa.com/virtual-internships/prototype/ms2CK9b2SCWGXwPMS/Engineering%3A%20Undergraduate%20%26%20Masters%20Virtual%20Internship%20Platform&quot;&gt;Virtual Intership&lt;/a&gt; 코스에 등록하게 되었다.&lt;/p&gt;

&lt;p&gt;간단하게 인턴십 소개를 들었다. 기술적인 내용을 가르친다기 보다는 마이크로소프트가 어떻게 일하고 전반적인 기술 트렌드를 소개하기 위한 프로그램이라는 느낌이 들었다. 단순한 소개인 Module 1을 마무리 하고 Module 2에서는 SMART한 목표설정을 다뤘다.&lt;/p&gt;

&lt;h3 id=&quot;smart한-목표란&quot;&gt;SMART한 목표란&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;Specific
구체적이고&lt;/li&gt;
  &lt;li&gt;Measurable
측정 가능하고&lt;/li&gt;
  &lt;li&gt;Achievable
달성 가능하고&lt;/li&gt;
  &lt;li&gt;Relevant
달성해야 하는 이유가 적당하며&lt;/li&gt;
  &lt;li&gt;Time Bound
시간 제약 안에 달성해야하는 목표이다.
&lt;a href=&quot;https://www.youtube.com/watch?v=PCRSVRD2EAk&quot;&gt;소개 영상&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;맞는 말인 것 같으면서도 과정에 대한 평가가 더해졌으면 어땠을까 하는 생각이 든다.&lt;/p&gt;

&lt;p&gt;스스로도 SMART한 골을 설정해봤다. 장기적이진 않고 단기 목표이지만 일단 이렇다.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;8월 15일까지 앞으로 공부할 인공지능에 필수적인 수학 공부(선형대수)를 하자. 선형대수 강의를 수강할 것이며 하루에 4강씩 수강한다. 상대적으로 쉬운 앞 부분을 빠르게 수강하면 가능할 것이라고 생각한다. 아마 하루 4시간씩 투자를 하게 될 것이다. 그날 공부한 내용을 블로그에 올리도록 하자&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;목표를 달성할 수 있게 스스로를 한번 채찍질 해보자.&lt;/p&gt;</content><author><name>Park Seung Joon</name></author><category term="personal" /><summary type="html">우연히 마이크로소프트에서 하는 Virtual Intership 코스에 등록하게 되었다.</summary></entry><entry><title type="html">Rouge 적용</title><link href="https://soonjune.github.io/rouge" rel="alternate" type="text/html" title="Rouge 적용" /><published>2020-08-05T17:00:00+09:00</published><updated>2020-08-05T17:00:00+09:00</updated><id>https://soonjune.github.io/rouge</id><content type="html" xml:base="https://soonjune.github.io/rouge">&lt;p&gt;Rouge를 이용하면 코드 부분을 highlight해서 표현할 수 있다.&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;```이용
    &lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;JavaScript is a simple language for javatpoint learners&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;~~~javascript로 열고 닫을 때
    &lt;div class=&quot;language-javascript highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;document&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;JavaScript is a simple language for javatpoint learners&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;syntaxHighlight&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;code&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;foo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'Hello World'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;bar&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;%highlight javascript %로 열고 % endhighlight % 닫을 때 중간에 코드가 들어가서 list ordering이 다시 1부터 시작하는 문제가 있었다.
마크다운 중간에 삽입하기 위해서는  &lt;br /&gt;
(1) html layout에서 아래와 같이 css style을 불러오고&lt;/p&gt;
&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;link&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;rel=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;stylesheet&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;type=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;text/css&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;href=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;/assets/built/syntax.css&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;(2) 코드 블럭(Code Blocks) 추가 - ``` 혹은 ~~~ 이용
코드 첫 줄과 마지막 줄에 Back quote ( ` ) 또는 물결( ~ ) 3개 삽입해서 추가하자.&lt;/p&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://medium.com/@vilcins/syntax-highlight-with-rouge-in-jekyll-6bf9e45f9dda&quot;&gt;https://medium.com/@vilcins/syntax-highlight-with-rouge-in-jekyll-6bf9e45f9dda&lt;/a&gt; &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;</content><author><name>Park Seung Joon</name></author><category term="blog" /><summary type="html">Rouge를 이용하면 코드 부분을 highlight해서 표현할 수 있다.1 https://medium.com/@vilcins/syntax-highlight-with-rouge-in-jekyll-6bf9e45f9dda &amp;#8617;</summary></entry><entry><title type="html">Blog Reopening - 블로그 운영 시작</title><link href="https://soonjune.github.io/blog-opening" rel="alternate" type="text/html" title="Blog Reopening - 블로그 운영 시작" /><published>2020-08-01T18:00:00+09:00</published><updated>2020-08-01T18:00:00+09:00</updated><id>https://soonjune.github.io/blog-opening</id><content type="html" xml:base="https://soonjune.github.io/blog-opening">&lt;!-- &lt;span class=&quot;table-of-contents-list&quot;&gt;블로그 목차 내역&lt;/span&gt;
&lt;ul class=&quot;table-of-contents-list&quot;&gt;
    &lt;li&gt;&lt;a href=&quot;./blog-opening&quot;&gt;블로그 목차 추가&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=acVpibElHZ8&amp;t=99s&quot;&gt;목차 추가시 참고 영상&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt; --&gt;

&lt;p&gt;블로그 재운영&lt;/p&gt;

&lt;p&gt;개설만 해놓고 흐지부지 됐던 블로그를 다시 운영하기로 했습니다. 공부, 일상 등 잡다한 내용을 다룰 예정입니다.
 열심히 기록을 남겨 스스로를 되돌아보고 좋은 정보도 공유하고자 합니다.&lt;/p&gt;

&lt;p&gt;블로그는 jekyll 기반의 static website이며 아래 자료를 참고했습니다. &lt;br /&gt;
&lt;a href=&quot;https://moon9342.github.io/tag/jekyll/&quot;&gt;IT Technical Training&lt;/a&gt;&lt;/p&gt;</content><author><name>Park Seung Joon</name></author><category term="blog" /><summary type="html"></summary></entry></feed>