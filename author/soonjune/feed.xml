<?xml version="1.0" encoding="utf-8"?>

<feed xmlns="http://www.w3.org/2005/Atom" >
  <generator uri="https://jekyllrb.com/" version="3.7.4">Jekyll</generator>
  <link href="http://localhost:4000/author/soonjune/feed.xml" rel="self" type="application/atom+xml" />
  <link href="http://localhost:4000/" rel="alternate" type="text/html" />
  <updated>2021-01-05T23:22:05+09:00</updated>
  <id>http://localhost:4000/author/soonjune/feed.xml</id>

  
  
  

  
    <title type="html">Seung Joon’s Blog | </title>
  

  
    <subtitle>Personal Blog of Park Seung Joon</subtitle>
  

  

  
    
      
    
  

  
  

  
    <entry>
      <title type="html">4. Subspace</title>
      <link href="http://localhost:4000/Linear-Algebra" rel="alternate" type="text/html" title="4. Subspace" />
      <published>2020-10-10T22:00:00+09:00</published>
      <updated>2020-10-10T22:00:00+09:00</updated>
      <id>http://localhost:4000/Linear-Algebra</id>
      <content type="html" xml:base="http://localhost:4000/Linear-Algebra">&lt;p&gt;서울대 데이터사이언스대학원 Bootcamp를 수강하면서 배운 내용을 정리해보고자 한다. 1주차에는 데이터사이언스를 위한 수학을 주제로 오민환 교수님께서 강의를 진행했다. 교재는 &lt;a href=&quot;https://mml-book.github.io/book/mml-book.pdf&quot;&gt;Mathematics for Machine Learning&lt;/a&gt;이라는 오픈 소스 교재를 사용하였다. 오늘은 Ch2까지 배운 선형대수의 기초적인 내용을 정리해본다.&lt;/p&gt;

&lt;h3 id=&quot;i-책-소개-intro&quot;&gt;I. 책 소개 (Intro)&lt;/h3&gt;
&lt;p&gt;교재에서는 머신러닝을 위한 기초적인 지식으로 3가지롤 꼽고 있다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;프로그래밍 언어 및 데이터 분석 도구&lt;/li&gt;
  &lt;li&gt;대규모 컴퓨팅 및 그와 관련된 프레임워크&lt;/li&gt;
  &lt;li&gt;수학, 통계 지식
이 책에서는 마지막 부분, 즉 수학과 연관된 부분을 다룬다. 모델 자체의 알고리즘에 초점을 맞추기보다는 수학적인 개념과 실용적인 궁금증을 해결하고자 노력했다고 저자는 밝히고 있다.
    &lt;h4 id=&quot;핵심-단어-데이터data-모델model-학습learning&quot;&gt;핵심 단어: 데이터(data), 모델(model), 학습(learning)&lt;/h4&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;ii-선형대수-linear-algebra&quot;&gt;II. 선형대수 (Linear Algebra)&lt;/h3&gt;
&lt;p&gt;(1) Geometric vectors / Polynomials =&amp;gt; They are both vectors. Audio signals, elements of $R^n are vectors.
(2) Closure(닫힘) - 그 집합의 원소와 관계가 있는 원소가 항상 그 집합에 속한다는 성질이다.
&lt;img src=&quot;https://miro.medium.com/max/4800/1*5haUfmOWQUh9N353hMy9KQ.png&quot; alt=&quot;mind-map&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;21-연립-일차-방정식-systems-of-linear-equations&quot;&gt;2.1 연립 일차 방정식 (Systems of Linear Equations)&lt;/h3&gt;
&lt;p&gt;해는 없거나 / 하나만 존재하거나 / 무수히 많을 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;22-행렬-matrices&quot;&gt;2.2 행렬 (Matrices)&lt;/h3&gt;
&lt;p&gt;연립 일차 방정식을 행렬을 이용해서 간결하게 표현할 수 있다. &lt;br /&gt;
행렬은 또한 선형 변환(Linear mapping)이라는 함수를 표현할 수 있다. &lt;br /&gt;
행렬의 덧셈과 곱셈 정의. 곱셈에 대하여 교환법칙이 성립하지 않는다.&lt;/p&gt;

&lt;h5 id=&quot;cf-아인슈타인-표기법&quot;&gt;cf. 아인슈타인 표기법&lt;/h5&gt;
&lt;p&gt;np.einsum을 이용해서 나타낼 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;222-역행렬과-전치행렬-inverse-and-transpose&quot;&gt;2.2.2 역행렬과 전치행렬 (Inverse and Transpose)&lt;/h3&gt;
&lt;p&gt;행렬 A의 역행렬이 존재하는 경우 regular/invertible/nonsingular라고 부름. &lt;br /&gt;
역행렬이 존재하면 고유(unique)하다.&lt;/p&gt;

&lt;p&gt;Theorem 증명&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;(Uniqueness of Inverse Matrix) If B and C are both inverses of an n × n matrix A, then B = C.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;$ B = B I_n = B(A C) = (B A)C =I_nC = C.$
결합 법칙을 이용해서 증명이 가능하다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;If $AB = I$ then $BA = I$
A, B를 n 정사각행렬이라 하고 n-dimensional 벡터 공간을 정의하면 AB의 range는 full space. 따라서 B의 range도 dimension n이다. &lt;br /&gt;
$𝐵=𝐵𝐼=𝐵(𝐴𝐵)=(𝐵𝐴)𝐵$. By the distributive law, $(𝐼−𝐵𝐴)𝐵=0$. B는 full range이므로 I-BA가 영행렬이 되어야 한다. 따라서 I = BA.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;=&amp;gt; full rank이면 invertible하다. &lt;a href=&quot;https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/matrices/full-rank-inv.html&quot;&gt;증명&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;이외에도 augmented matrix를 Gaussian eliminiation을 통해서 Row-Echelon Form으로 변환한 뒤 연랍 일차 방정식을 푸는 방법에 대해서 공부하였다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Park Seung Joon</name>
        
        
      </author>

      

      
        <category term="linear-algebra" />
      
        <category term="math" />
      

      
        <summary type="html">서울대 데이터사이언스대학원 Bootcamp를 수강하면서 배운 내용을 정리해보고자 한다. 1주차에는 데이터사이언스를 위한 수학을 주제로 오민환 교수님께서 강의를 진행했다. 교재는 Mathematics for Machine Learning이라는 오픈 소스 교재를 사용하였다. 오늘은 Ch2까지 배운 선형대수의 기초적인 내용을 정리해본다.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">4. Subspace</title>
      <link href="http://localhost:4000/Subspace" rel="alternate" type="text/html" title="4. Subspace" />
      <published>2020-10-10T22:00:00+09:00</published>
      <updated>2020-10-10T22:00:00+09:00</updated>
      <id>http://localhost:4000/Subspace</id>
      <content type="html" xml:base="http://localhost:4000/Subspace">&lt;p&gt;오늘은 mit Gilbert Strang 선생님의 선형대수 Subspace에 관한 부분을 정리해 보았다.&lt;/p&gt;

&lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML&quot;&gt;
&lt;/script&gt;

&lt;h3 id=&quot;i-4-fundamental-subspaces&quot;&gt;I. 4 Fundamental Subspaces&lt;/h3&gt;
&lt;p&gt;A is m x n&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;columnspace C(A) in &lt;script type=&quot;math/tex&quot;&gt;R^m&lt;/script&gt;  &lt;br /&gt;
dimension of C(A) = # of pivot columns = rank r&lt;/li&gt;
  &lt;li&gt;nullspace N(A) in &lt;script type=&quot;math/tex&quot;&gt;R^n&lt;/script&gt;  &lt;br /&gt;
dimension of N(A) = # of free variables = n - r&lt;/li&gt;
  &lt;li&gt;rowspace = all combs of rows = all combs of columns = &lt;script type=&quot;math/tex&quot;&gt;A^T = C(A^T)&lt;/script&gt;  &lt;br /&gt;
same dimension as columnspace&lt;/li&gt;
  &lt;li&gt;nullspace of &lt;script type=&quot;math/tex&quot;&gt;A^T&lt;/script&gt; N(&lt;script type=&quot;math/tex&quot;&gt;A^T&lt;/script&gt;) = left nullspace of A &lt;br /&gt;
dimension = m - r
left nullspace라는 이름은 row벡터로 만들면 왼쪽에 오기 때문 (&lt;script type=&quot;math/tex&quot;&gt;y^TA = O&lt;/script&gt;)&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;ii-orthogonal-vectors-and-subspaces&quot;&gt;II. Orthogonal Vectors and Subspaces&lt;/h3&gt;
&lt;p&gt;1) Test for orthogonality: dot product is zero(&lt;script type=&quot;math/tex&quot;&gt;X^Ty = 0&lt;/script&gt;) &lt;br /&gt;
orthogonal한 벡터 간에는 피타고라스 정리가 성립한다. &lt;br /&gt;
&lt;script type=&quot;math/tex&quot;&gt;X^TX + Y^TY = (X+Y)^T(X+Y)&lt;/script&gt; &lt;br /&gt;
2) Subspace S와 T가 orthogonal하다는 것의 의미 &lt;br /&gt;
S에 속한 모든 벡터가 T에 속한 모든 벡터와 orthogonal하다. &lt;br /&gt;
=&amp;gt; Rowspace is Orthogonal to nullspace - 이유
&lt;script type=&quot;math/tex&quot;&gt;Ax = O&lt;/script&gt; &lt;br /&gt;
=&amp;gt; Rowspace and Nullspace are orthogonal complements in &lt;script type=&quot;math/tex&quot;&gt;R^n&lt;/script&gt; // 둘의 dimension을 더하면 n 
Nullspace contains all vectors perpendicular to rowspace&lt;/p&gt;

&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;Ax = b&lt;/script&gt; =&amp;gt; 양쪽변에 &lt;script type=&quot;math/tex&quot;&gt;A^T&lt;/script&gt;를 곱해준다.
How to “solve” the equation when there is no solution?  &lt;br /&gt;
m &amp;gt; n&lt;br /&gt;
실생활에서 noise 때문에 A를 제대로 알 수 없는 경우 - noise를 제거해야.&lt;br /&gt;
&lt;script type=&quot;math/tex&quot;&gt;A^TA&lt;/script&gt;: square, symmetric, invertible?
&lt;script type=&quot;math/tex&quot;&gt;N(A^TA) = N(A)&lt;/script&gt; &lt;br /&gt;
rank of &lt;script type=&quot;math/tex&quot;&gt;A^TA&lt;/script&gt; = rank of A &lt;br /&gt;
&lt;script type=&quot;math/tex&quot;&gt;A^TA&lt;/script&gt; is invertible exactly if A has independent columns&lt;/p&gt;

&lt;h3 id=&quot;iii-projections-onto-subspaces&quot;&gt;III. Projections onto Subspaces&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;Projection Matrix (P) &lt;br /&gt;
projp = Pb   P = &lt;script type=&quot;math/tex&quot;&gt;(aa^T) / (a^Ta)&lt;/script&gt; &lt;br /&gt;
columnspace of C(P) = line through a &lt;br /&gt;
rank(P) = 1 &lt;br /&gt;
    &lt;ul&gt;
      &lt;li&gt;P is symmetric&lt;/li&gt;
      &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;P^2 = P&lt;/script&gt; &lt;br /&gt;
Projection이 필요한 이유? Ax=b의 해가 없을 수도 있어서
가장 비슷한 문제를 푼다. =&amp;gt; Solve Ax = p(proj of b onto columnspace)
Key: b-Ax is perpendicular to plane
&lt;script type=&quot;math/tex&quot;&gt;(a_1)^T(b-Ax)=0, (a_2)^T(b-Ax)=0&lt;/script&gt;&lt;br /&gt;
&lt;script type=&quot;math/tex&quot;&gt;A^T(b-Ax) = O&lt;/script&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;What subsapce is error vector e(b-Ax) in?&lt;br /&gt;
e is in &lt;script type=&quot;math/tex&quot;&gt;N(A^T)&lt;/script&gt;  =&amp;gt;
e is perpendicular to C(A) &lt;br /&gt;
&lt;script type=&quot;math/tex&quot;&gt;A^TAx = A^Tb&lt;/script&gt; &lt;br /&gt;
&lt;script type=&quot;math/tex&quot;&gt;x = (A^TA)^(-1)A^Tb&lt;/script&gt;
P = Ax = A(A^TA)^(-1)A^Tb&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;script type=&quot;math/tex; mode=display&quot;&gt;P^T = P&lt;/script&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;P^2 = P&lt;/script&gt; &lt;br /&gt;
Application: Least squares fitting by a line &lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;</content>

      
      
      
      
      

      <author>
          <name>Park Seung Joon</name>
        
        
      </author>

      

      
        <category term="linear-algebra" />
      
        <category term="math" />
      

      
        <summary type="html">오늘은 mit Gilbert Strang 선생님의 선형대수 Subspace에 관한 부분을 정리해 보았다.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">3. Determinant</title>
      <link href="http://localhost:4000/Determinants" rel="alternate" type="text/html" title="3. Determinant" />
      <published>2020-10-04T22:00:00+09:00</published>
      <updated>2020-10-04T22:00:00+09:00</updated>
      <id>http://localhost:4000/Determinants</id>
      <content type="html" xml:base="http://localhost:4000/Determinants">&lt;p&gt;오랜만에 선형대수 정리를 다시 시작한다. 오늘은 판별식(Determinant)에 대해 알아보자.
판별식은 고유값(eigenvalue)을 구하기 위해 필요한 식 중 하나다.
유명한 &lt;a href=&quot;https://www.youtube.com/watch?v=srxexLishgY&quot;&gt;Gilbert Strang 선생님의 MIT 강의&lt;/a&gt;를 나만의 말로 정리해 보았다.&lt;/p&gt;

&lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML&quot;&gt;
&lt;/script&gt;

&lt;h3 id=&quot;판별식의-성질&quot;&gt;판별식의 성질&lt;/h3&gt;
&lt;p&gt;1) det I = 1 &lt;br /&gt;
2) 두 행을 바꾼 행렬의 판별식은 부호가 반대다. &lt;br /&gt;
3a) 한 행에 t를 곱하면 전체에 본래 판별식에 t를 곱한 것과 같다. &lt;br /&gt;
3b) 한 행에만 임의 값을 더해주면 본래 판별식에 더해주는 값을 분리한 행렬(나머지 행의 값은 동일)의 판별식의 합과 같다. &lt;br /&gt;
Determinant is Linear Each Row &lt;br /&gt;
4) 두 행의 값이 같으면 =&amp;gt; 판별식은 0이다.(2로부터 유도) &lt;br /&gt;
5) 한 행을 곱해서 다른 행에서 빼도 판별식이 달라지지 않는다.(3b, 3a, 4로부터 유도) &lt;br /&gt;
6) 한 행의 원소가 모두 0이라면 판별식도 0이다.(3a 또는 3b로 유도) &lt;br /&gt;
7) 삼각행렬의 판별식은 대각선에 위치한 원소들의 곱이다. (소프트웨어에서 판별식을 구하는 방식 -&amp;gt; 삼각행렬도 만들어서 대각선 곱한다. 3a를 이용해서 행마다 factor out하면 대각선 곱과 1이 남는다.)&lt;br /&gt;
8) 행렬의 역행렬이 존재하지 않으면 판별식은 0이다. &lt;br /&gt;
9) det AB = (det A) * (det B) &lt;br /&gt;
10) &lt;script type=&quot;math/tex&quot;&gt;detA^T = detA&lt;/script&gt; =&amp;gt; 열이 다 0이어도 판별식은 0이다를 보일 수 있다. (증명은 &lt;script type=&quot;math/tex&quot;&gt;|U^T||L^T| = |L||U|&lt;/script&gt; 보임으로써 할 수 있다.) &lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;판별식-공식&quot;&gt;판별식 공식&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://wikimedia.org/api/rest_v1/media/math/render/svg/b5300123cfe333f7a1e78d8dab5eb044d0be1548&quot; /&gt;
소행렬식(Minor) &lt;script type=&quot;math/tex&quot;&gt;M_(ij)&lt;/script&gt;는 i행과 j열을 제외한 행렬식이다.
아래서 보듯, cofactor는 i+j가 짝수이면 양수 i+j가 홀수이면 음수를 앞에 곱한다.
&lt;img src=&quot;https://wikimedia.org/api/rest_v1/media/math/render/svg/279a8d3f0f8f1338b8d2a4f80f1323f514edf60d&quot; /&gt;
&lt;img src=&quot;https://wikimedia.org/api/rest_v1/media/math/render/svg/089ce40623558856f6cd09a7c0dc23fded7d1e08&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;cofactor를-이용한-역행렬-구하기&quot;&gt;Cofactor를 이용한 역행렬 구하기&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://wikimedia.org/api/rest_v1/media/math/render/svg/0651000d4523a0563cd016ae064f75011e0d8702&quot; /&gt;
&lt;img src=&quot;https://wikimedia.org/api/rest_v1/media/math/render/svg/5b076e517a662a54fe32bfcd7ca2ec8a1998b139&quot; /&gt;
&lt;script type=&quot;math/tex&quot;&gt;AC^T = (detA)I&lt;/script&gt;임을 보이면 된다. 행렬곱의 대각선은 detA가 되고 나머지는 0이 된다는 것을 알 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;cramers-rule&quot;&gt;Cramer’s Rule&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://wikimedia.org/api/rest_v1/media/math/render/svg/4b063cb0d9acc0aed7f58ad881d845a2e2598e7f&quot; /&gt;&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Park Seung Joon</name>
        
        
      </author>

      

      
        <category term="linear-algebra" />
      
        <category term="math" />
      

      
        <summary type="html">오랜만에 선형대수 정리를 다시 시작한다. 오늘은 판별식(Determinant)에 대해 알아보자. 판별식은 고유값(eigenvalue)을 구하기 위해 필요한 식 중 하나다. 유명한 Gilbert Strang 선생님의 MIT 강의를 나만의 말로 정리해 보았다.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Pythonic Thinking(4) 파이썬 효율적으로 사용하기</title>
      <link href="http://localhost:4000/Effective-Python1_4" rel="alternate" type="text/html" title="Pythonic Thinking(4) 파이썬 효율적으로 사용하기" />
      <published>2020-09-01T23:30:00+09:00</published>
      <updated>2020-09-01T23:30:00+09:00</updated>
      <id>http://localhost:4000/Effective-Python1_4</id>
      <content type="html" xml:base="http://localhost:4000/Effective-Python1_4">&lt;p&gt;첫번째 챕터 Pythonic Thinking의 10번 팁을 간단하게 요약해보자. 개학도 해서 일찍 자야하고 10번 팁이 긴 편이라 하나만 정리하자.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;할당(Assignment; =) 표현으로 인한 반복을 피해라 (Python 3.8)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;아직 개발중인 Python 3.8의 walrus(바다코끼리) 연산자에 대한 내용이다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;walrus 연산자(:=)를 사용해서 존재하지 않는 변수에 대하여 할당과 동시에 사용이 한줄로 가능하다.&lt;/li&gt;
  &lt;li&gt;변수 할당이 다른 큰 표현 안에서 이루어지는 경우(예 if문에서의 대소 비교)에는 괄호&lt;code class=&quot;highlighter-rouge&quot;&gt;()&lt;/code&gt;를 안에 넣어주자.&lt;/li&gt;
  &lt;li&gt;파이썬에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;switch/case&lt;/code&gt;문과 &lt;code class=&quot;highlighter-rouge&quot;&gt;do/while&lt;/code&gt; 반복문이 존재하지 않지만 앞서 말한 walrus 연산자를 활용하면 간결하게 표현이 가능하다. (아래 예시 참조)
    &lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# 재료(과일 딕셔너리로 존재)가 허락하는 가장 좋은 주스를 갖는 경우 switch/case 문&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fresh_fruit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'banana'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;c&quot;&gt;# 바나나는 잘라야 된다.&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;pieces&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;slice_bananas&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;to_enjoy&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;make_smoothies&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pieces&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;elif&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fresh_fruit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'apple'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;to_enjoy&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;make_cider&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;elif&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fresh_fruit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'apple'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;to_enjoy&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;make_lemonade&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;to_enjoy&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'Nothing'&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# 모든 재료를 소진하여 주스 병을 만드는 경우 do/while 문&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;bottles&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fresh_fruit&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pick_fruit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fruit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fresh_fruit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;items&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;batch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;make_juice&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fruit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;bottles&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;extend&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;batch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;출처: Slatkin, B. (2020). Effective Python: 90 specific ways to write better Python. USA: Addison-Wesley.&lt;/em&gt;&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Park Seung Joon</name>
        
        
      </author>

      

      
        <category term="python" />
      

      
        <summary type="html">첫번째 챕터 Pythonic Thinking의 10번 팁을 간단하게 요약해보자. 개학도 해서 일찍 자야하고 10번 팁이 긴 편이라 하나만 정리하자.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">부자되기 도서 2개 소개</title>
      <link href="http://localhost:4000/how-to-become-rich" rel="alternate" type="text/html" title="부자되기 도서 2개 소개" />
      <published>2020-08-31T23:30:00+09:00</published>
      <updated>2020-08-31T23:30:00+09:00</updated>
      <id>http://localhost:4000/how-to-become-rich</id>
      <content type="html" xml:base="http://localhost:4000/how-to-become-rich">&lt;p&gt;이번 방학기간 동안 읽은 부자학(?) 관련 서적 2개를 소개하고자 한다.&lt;/p&gt;

&lt;h3 id=&quot;how-to-get-rich-one-of-the-worlds-greatest-entrepreneurs-shares-his-secrets&quot;&gt;&lt;a href=&quot;https://www.goodreads.com/book/show/1837402.How_to_Get_Rich&quot;&gt;How to Get Rich: One of the World’s Greatest Entrepreneurs Shares His Secrets&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;세계적인 잡지 맥심의 설립자인 Felix Dennis의 전기적인 책이다. 부자가 되는 법을 자세히 소개하고 있는데 맨 마지막 엑기스만 소개한다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;너의 필요를 분석하라. 욕구로는 부족하다. 충동은 필수적이다.&lt;/li&gt;
  &lt;li&gt;부정적인 영향을 미치는 것들로부터 벗어나라. 포기하지 마라. 목표를 향해 나아가라.&lt;/li&gt;
  &lt;li&gt;“대단한 아이디어”는 무시해라. 행동이 중요하다.&lt;/li&gt;
  &lt;li&gt;집중해라. 돈은 도처에 널려있다.&lt;/li&gt;
  &lt;li&gt;너보다 똑똑한 사람에게 일을 위임해라. 성과를 공유해라.&lt;/li&gt;
  &lt;li&gt;소유권은 비밀 비법이다. (회사를) 소유할 수 있을만큼 소유해라.&lt;/li&gt;
  &lt;li&gt;(회사를) 팔아야할 때가 오기 전 또는 재미가 없어지면 팔아라. 협상을 할 때에는 머리를 비워라.&lt;/li&gt;
  &lt;li&gt;아무것도 두려워 하지 마라. 부자가 돼라. 베풀어라.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;위 내용을 저자의 경험을 기반으로 주장한다. 또 다른 책은 위와는 맥락이 조금 다르다.&lt;/p&gt;

&lt;h3 id=&quot;이웃집-백만장자-변하지-않는-부의-법칙--흔들리지-않는-부는-어떻게-축적되는가&quot;&gt;이웃집 백만장자 변하지 않는 부의 법칙 : 흔들리지 않는 부는 어떻게 축적되는가&lt;/h3&gt;
&lt;p&gt;위 아버지 대부터 부자들을 연구해온 토머스 스탠리 박사가 통계를 기반으로 부자에 관한 내용을 설명한다.
부를 축적하는 자들과 그렇지 못한 두 부류로 나누어 설명하고 있다. 상세한 내용은 &lt;a href=&quot;https://en.wikipedia.org/wiki/The_Millionaire_Next_Door&quot;&gt;위키백과&lt;/a&gt;에도 있으니 참조하면 된다.&lt;/p&gt;

&lt;p&gt;다만, 앞서 소개한 책과의 차이를 저축과 근검함을 강조하고 있다는 것에서 볼 수 있다. 부자가 되는 것에 답은 없지만 결국 돈이라는 것도 행복해지기 위한 수단임을 명심하자.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Park Seung Joon</name>
        
        
      </author>

      

      
        <category term="book-review" />
      

      
        <summary type="html">이번 방학기간 동안 읽은 부자학(?) 관련 서적 2개를 소개하고자 한다.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Pythonic Thinking(3) 파이썬 효율적으로 사용하기</title>
      <link href="http://localhost:4000/Effective-Python1_3" rel="alternate" type="text/html" title="Pythonic Thinking(3) 파이썬 효율적으로 사용하기" />
      <published>2020-08-30T23:30:00+09:00</published>
      <updated>2020-08-30T23:30:00+09:00</updated>
      <id>http://localhost:4000/Effective-Python1_3</id>
      <content type="html" xml:base="http://localhost:4000/Effective-Python1_3">&lt;p&gt;첫번째 챕터 Pythonic Thinking의 7-9번 팁을 간단하게 요약해보자.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Range 대신 &lt;code class=&quot;highlighter-rouge&quot;&gt;Enumerate&lt;/code&gt;를 쓰자.
    &lt;ul&gt;
      &lt;li&gt;간결하게 iterator와 index를 이용할 수 있다.&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;range&lt;/code&gt;를 이용해서 loop를 돌면서 indexing을 하기보다 &lt;code class=&quot;highlighter-rouge&quot;&gt;enumerate&lt;/code&gt;를 사용하자.&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;enumerate&lt;/code&gt;의 두번째 파라미터를 이용해서 0 이외의 숫자부터 indexing할 수 있다. 아래 예시
        &lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;flavor&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;enumerate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flavor_list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'{i}: {flavor}'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Iterator들을 병렬적으로 처리하기 위해 &lt;code class=&quot;highlighter-rouge&quot;&gt;zip&lt;/code&gt;을 사용하자.
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;enumerate&lt;/code&gt;와 마찬가지로 &lt;code class=&quot;highlighter-rouge&quot;&gt;zip&lt;/code&gt;이라는 기본 함수를 사용해서 여러 iterator들을 병렬적으로 처리할 수 있다.&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;zip&lt;/code&gt;은 iterator의 다음 값에 해당하는 값들을 tuple의 형태로 그때 그때 하나씩 생성한다(lazy generator). 따라서 메모리 걱정 없이 무한정 긴 iterator를 처리할 수 있다.&lt;/li&gt;
      &lt;li&gt;비교하는 두 iterator의 길이가 다르면 작은 쪽까지만 tuple을 생성하고 멈춘다.&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;itertools&lt;/code&gt; 모듈의 &lt;code class=&quot;highlighter-rouge&quot;&gt;zip_longest&lt;/code&gt;를 사용하면 길이가 긴 iterator에 맞춰서 tuple을 생성할 수 있다(짧은 쪽의 값엔 None이 default로 들어간다).&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;for&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;while&lt;/code&gt;문 다음에는 &lt;code class=&quot;highlighter-rouge&quot;&gt;else&lt;/code&gt; 사용을 지양하자.
    &lt;ul&gt;
      &lt;li&gt;for나 while문 뒤에 else가 오게되면 어떻게 되는지 알자.&lt;/li&gt;
      &lt;li&gt;break를 사용하게 되면 뒤에 else가 실행되지 않는다.&lt;/li&gt;
      &lt;li&gt;따라서 헷갈리고 비직관적인 반복문 뒤 &lt;code class=&quot;highlighter-rouge&quot;&gt;else&lt;/code&gt; 사용을 지양하자.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;em&gt;출처: Slatkin, B. (2020). Effective Python: 90 specific ways to write better Python. USA: Addison-Wesley.&lt;/em&gt;&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Park Seung Joon</name>
        
        
      </author>

      

      
        <category term="python" />
      

      
        <summary type="html">첫번째 챕터 Pythonic Thinking의 7-9번 팁을 간단하게 요약해보자.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Pythonic Thinking(2) 파이썬 효율적으로 사용하기</title>
      <link href="http://localhost:4000/Effective-Python1_2" rel="alternate" type="text/html" title="Pythonic Thinking(2) 파이썬 효율적으로 사용하기" />
      <published>2020-08-27T23:30:00+09:00</published>
      <updated>2020-08-27T23:30:00+09:00</updated>
      <id>http://localhost:4000/Effective-Python1_2</id>
      <content type="html" xml:base="http://localhost:4000/Effective-Python1_2">&lt;p&gt;첫번째 챕터 Pythonic Thinking의 4-6번 팁을 간단하게 요약해보자.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;F-String을 C-Style Format, str.format보다 우선해서 사용하자.
 Formatting은 미리 정의된 텍스트와 데이터 값을 사람이 이해할 수 있게 합쳐서 하나의 문자열로 표현하는 과정을 말한다.
    &lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b10111011&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0xc5f&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'Binary is &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;d, hex is &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;d'&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;위 코드에서 % 옆의 부분을 format string이라고 부르며, %d 부분을 오른쪽의 값들이 대체한다. %는 C의 &lt;code class=&quot;highlighter-rouge&quot;&gt;printf&lt;/code&gt; 함수로부터 유래한다. 따라서 이러한 format을 C-style format이라 부른다. C 언어를 사용하던 프로그래머라면 이러한 C-style format string을 사용하는데 익숙하겠지만 네가지 문제가 존재한다.&lt;/p&gt;
    &lt;ol&gt;
      &lt;li&gt;데이터의 타입이 바뀌면 에러를 발생시킨다.&lt;/li&gt;
      &lt;li&gt;읽기 어려워 수정이 쉽지 않다.&lt;/li&gt;
      &lt;li&gt;똑같은 format string을 여러번 사용하고 싶을 때, 오른쪽의 tuple을 반복해야 한다.&lt;/li&gt;
      &lt;li&gt;3번 문제 해결을 위해 dictionary를 이용할 수 있지만 오른쪽의 key를 최소 두번 지정해줘야 한다.(오른쪽의 format specifier에서 한번, dictionary에서 한번)&lt;/li&gt;
    &lt;/ol&gt;

    &lt;p&gt;Python3에서부터 str.format을 이용하여 &lt;code class=&quot;highlighter-rouge&quot;&gt;%&lt;/code&gt; 대신 &lt;code class=&quot;highlighter-rouge&quot;&gt;{}&lt;/code&gt;을 placeholder로 사용할 수 있게 됐다.   &lt;br /&gt;
 하지만 이 또한 위의 2번, 4번 문제를 해결하지 못한다는 문제가 있다.&lt;/p&gt;

    &lt;p&gt;따라서 간결하면서도 강력한 f-string을 사용하자. f-string을 이용하면 아래와 같이 format specifier 안에 직접 파이썬 표현을 추가할 수 있어 유용하다.&lt;/p&gt;
    &lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;enumerate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pantry&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
     &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'#{i+1}: '&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'{item.title():&amp;lt;10s} = '&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'{round(count)}'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;복잡한 표현 대신 헬퍼 함수를 사용하자.
    &lt;ul&gt;
      &lt;li&gt;한 줄로 된 복잡한 코드보다는 반복 사용되는 로직인 경우 헬퍼 함수를 사용하는 것이 명확하다.&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;if/else&lt;/code&gt;를 하용하는 것이 Boolean &lt;code class=&quot;highlighter-rouge&quot;&gt;or&lt;/code&gt; 또는 &lt;code class=&quot;highlighter-rouge&quot;&gt;and&lt;/code&gt;를 사용하는 것보다 가독성을 높인다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Multiple Assignment Unpacking을 Indexing 대신 사용하자.
    &lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;n&quot;&gt;item&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'Peanut butter'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'Jelly'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
 &lt;span class=&quot;c&quot;&gt;# Indexing 예시&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;first&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;second&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;item&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'and'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;second&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
 &lt;span class=&quot;c&quot;&gt;# Mulitple Assignment Unpacking 예시&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;second&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;item&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'and'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;second&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;Unpacking을 통해 &lt;code class=&quot;highlighter-rouge&quot;&gt;a, b = b, a&lt;/code&gt;와 같이 swap하는 것도 유용하다.&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;list, str, tuple 같은 모든 iterable에 unpacking을 사용할 수 있다. (iterable 안에 iterable에 대해서도 사용 가능)&lt;/li&gt;
      &lt;li&gt;Indexing 대신 unpacking을 사용해서 코드의 명확성을 높이자.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;em&gt;출처: Slatkin, B. (2020). Effective Python: 90 specific ways to write better Python. USA: Addison-Wesley.&lt;/em&gt;&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Park Seung Joon</name>
        
        
      </author>

      

      
        <category term="python" />
      

      
        <summary type="html">첫번째 챕터 Pythonic Thinking의 4-6번 팁을 간단하게 요약해보자.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Pythonic Thinking(1) 파이썬 효율적으로 사용하기</title>
      <link href="http://localhost:4000/Effective-Python1_1" rel="alternate" type="text/html" title="Pythonic Thinking(1) 파이썬 효율적으로 사용하기" />
      <published>2020-08-26T23:30:00+09:00</published>
      <updated>2020-08-26T23:30:00+09:00</updated>
      <id>http://localhost:4000/Effective-Python1_1</id>
      <content type="html" xml:base="http://localhost:4000/Effective-Python1_1">&lt;p&gt;유명한 Effective 시리즈의 Python 부분을 읽고 정리하고자 한다. 효율적인 코드 작성을 위한 90가지 방법 중 하루에 3가지씩 정리해보자.&lt;/p&gt;

&lt;p&gt;첫번째 챕터는 Pythonic Thinking이다. Pythonic이라는 것이 형용사로 만들어질만큼 C나 Java와는 다른 특성을 지는 것을 알 수 있다. Pythonic의 정의를 찾아보니 Stack Overflow에서는 &lt;code class=&quot;highlighter-rouge&quot;&gt;Exploiting the features of the Python language to produce code that is clear, concise and maintainable.&lt;/code&gt;이라는 설명이 나온다. 즉, 파이썬 코드의 간결하고 명확한 특성을 나타내는 말이다. Pythonic Thinking은 이러한 명확한 코드를 구현하기 위한 생각 방식이라고 볼 수 있다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;파이썬 버전을 알자
 최신 버전은 Python 3.8이다(2020년 8월 기준). 커맨드 또는 터미널에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;python3 --version&lt;/code&gt; 또는 &lt;code class=&quot;highlighter-rouge&quot;&gt;python --version&lt;/code&gt;을 통해서 버전을 확인할 수 있다. 맥의 경우 python 2.7이 기본으로 설치되어 있는데 새로 Python 3을 설치해주자.
    &lt;ul&gt;
      &lt;li&gt;명령 프롬트에서 올바른 버전의 파이썬이 설치되어 있는지 확인하자.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;PEP8 스타일 가이드를 따르자
    &lt;ul&gt;
      &lt;li&gt;PEP8 가이드에 대해 정리가 잘 된 &lt;a href=&quot;https://wayhome25.github.io/python/2017/05/04/pep8/&quot;&gt;블로그&lt;/a&gt;를 참조하자.&lt;/li&gt;
      &lt;li&gt;공통의 스타일을 사용함으로써 협업을 용이하게 할 수 있다.&lt;/li&gt;
      &lt;li&gt;일관적인 스타일의 사용은 추후 자신의 코드 수정을 용이하게 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;bytes&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;str&lt;/code&gt;의 차이를 알자.
    &lt;ul&gt;
      &lt;li&gt;bytes: 8-bit values    &lt;br /&gt;
 str: Unicode cdoe points&lt;/li&gt;
      &lt;li&gt;헬퍼 함수(개발자의 편의를 위한 함수)를 이용해서 원하는 문자 시퀀스 타입을 리턴하도록 하자.&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;bytes&lt;/code&gt;와 &lt;code class=&quot;highlighter-rouge&quot;&gt;str&lt;/code&gt; 인스턴스는 서로 연산할 수 없다 (&amp;gt;, ==, +, % 등).&lt;/li&gt;
      &lt;li&gt;바이너리 데이터를 읽고 쓰기 위해서는 ‘rb’, ‘wb’ 모드에서 파일을 &lt;code class=&quot;highlighter-rouge&quot;&gt;open&lt;/code&gt;한다.
        &lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;k&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'data.bin'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'wb'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\xf1\xf2\xf3\xf4\xf5&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
        &lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;k&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'data.bin'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'rb'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;Unicode 데이터를 읽고 쓸 때에는 시스템의 디폴트 인코딩에 주의해라. encoding parameter를 명시적으로 전달하자. &lt;br /&gt;
 아래는 윈도우의 ‘cp1252’로 인코딩된 파일을 읽는 예시.
        &lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;k&quot;&gt;with&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'data.bin'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'r'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;encoding&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'cp1252) as f:&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;  data = f.read()&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;em&gt;출처: Slatkin, B. (2020). Effective Python: 90 specific ways to write better Python. USA: Addison-Wesley.&lt;/em&gt;&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Park Seung Joon</name>
        
        
      </author>

      

      
        <category term="python" />
      

      
        <summary type="html">유명한 Effective 시리즈의 Python 부분을 읽고 정리하고자 한다. 효율적인 코드 작성을 위한 90가지 방법 중 하루에 3가지씩 정리해보자.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">면접 대비 - 인공지능, 기계학습 개념 복습</title>
      <link href="http://localhost:4000/AI-Review" rel="alternate" type="text/html" title="면접 대비 - 인공지능, 기계학습 개념 복습" />
      <published>2020-08-17T23:30:00+09:00</published>
      <updated>2020-08-17T23:30:00+09:00</updated>
      <id>http://localhost:4000/AI-Review</id>
      <content type="html" xml:base="http://localhost:4000/AI-Review">&lt;p&gt;면접 대비를 위해서 정리한 내용을 간단히 써보고자 한다.&lt;/p&gt;

&lt;h2 id=&quot;1-machine-learning-정의&quot;&gt;1. Machine Learning 정의&lt;/h2&gt;
&lt;h3 id=&quot;well-posed-learning-problem-by-tom-mitchell&quot;&gt;Well-posed learning problem by Tom Mitchell&lt;/h3&gt;
&lt;p&gt;경험(E)이 늘어남에 따라 특정 작업(T)를 수행하는 지표(P)의 개선이 이루어 질 때 기계가 학습한다고 정의할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;2-지도비지도-학습-강화학습&quot;&gt;2. 지도/비지도 학습, 강화학습&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;지도 학습 - 정답과 오답이 주어져서 training set을 바탕으로 정확도 높은 함수를 학습하는 것이 목표이다. 연속적인 데이터를 바탕으로 예측하는 회귀 문제나 비연속적인 데이터를 분류하는 Classification 문제가 지도 학습의 예이다.&lt;/li&gt;
  &lt;li&gt;비지도 학습 - 어떤 명시적인 정답이 주어지지 않고 데이터의 특성을 파악하는 과정이라고 할 수 있다. Clustering, Anomaly detection, association, autoencoder와 같은 문제가 해당된다.&lt;/li&gt;
  &lt;li&gt;강화학습 - Agent가 가장 reward가 높은 policy를 학습하는 학습 방법이다. 이제부터 강화학습에 대해 좀 더 알아보자.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;search-problem&quot;&gt;Search Problem&lt;/h2&gt;
&lt;p&gt;4가지 요소를 갖는다. - state space, successor function(action, cost), start sate/goal state   &lt;br /&gt;
여기서 start state에서 goal state까지 도달하게 만드는 일련의 action을 solution이라고 한다.&lt;/p&gt;
&lt;h3 id=&quot;1-uninformed-search&quot;&gt;1. Uninformed Search&lt;/h3&gt;
&lt;p&gt;어떤 그래프(State Space Graph) 또는 트리(Search Tree)를 탐색하는 문제에서 아무런 정보가 주어지지 않은 상태이다. DFS, BFS를 통해 완전탐색을 할 수 있다. 그래프는 각각의 상태가 한나의 노드로만 표현되기에 사이즈가 작다는 장점이 있고 트리는 상태가 여러번 등장하기도 하지만 goal state까지 하나의 고유한 path로 나타낼 수 있다는 장점이 있다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Uniform Cost Search - 모든 옵션까지의 비용을 계산해서 가장 비용이 작은 노드를 확장한다.(Optimal, Complete, but Slow)
    &lt;h3 id=&quot;2-informed-search&quot;&gt;2. Informed Search&lt;/h3&gt;
  &lt;/li&gt;
  &lt;li&gt;Gready Search - Heuristic function(goal에 가까운 정도를 예측하는 함수)에 따라 goal state에 가장 가깝다고 생각되는 node를 expand한다. Optimal한 solution을 보장하지 못한다.&lt;/li&gt;
  &lt;li&gt;A* Search(Best of both worlds - optimal &amp;amp; fast)&lt;/li&gt;
  &lt;li&gt;조건: Admissible(Optimistic) Heuristic - goal까지의 true cost보다 높게(비관적인) 전망을 하지 않아야 한다.   &lt;br /&gt;
똑같은 node를 두번 탐색하지 않도록 Graph Search에서는 Consistency 조건이 필요하다. 하나의 arc(간선)의 비용 예측이 실제 비용보다 작아야한다.
f = h + g
goal에 더 가까운 지점 B보다 goal에서 먼 A가 더 먼저 fringe에 들어간다는 것을 보이는 것으로 optmiality를 증명할 수 있다.
    &lt;h3 id=&quot;3-adverserial-search&quot;&gt;3. Adverserial Search&lt;/h3&gt;
  &lt;/li&gt;
  &lt;li&gt;Minimax는 deterministic &amp;amp; perfect information 게임에서 상대방이 optimal한 선택을 한다고 가정하고 상대가 나에게 가장 불리한 선택할 것을 가정한뒤 선택에 임한다. 내가 Max agent인 경우에는 상대가 선택한 최소 reward 중에서 가장 큰 것을 선택하게 되고 min agent는 그 반대로 행동할 것이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Pruning - 선택되지 않을 것들을 탐색에서 제외할 수 있다. 알파-베타 프루닝을 통해서 Max agent는 탐색과정에서 얻을 수 있는 최대 value(알파), Min agent는 탐색과정에서 얻을 수 있는 최소 value(베타)와 새로운 노드를 비교해서 탐색하게 되는 노드 수를 줄이는 과정을 거친다.   &lt;br /&gt;
Minimizer: v &amp;gt; alpha =&amp;gt; prune
Maximizer: v &amp;lt; beta =&amp;gt; prune&lt;/p&gt;

&lt;p&gt;Expectimax는 상대방이 최적의 선택을 하지 않는다고 가정하고 확률을 도입해서 expected value가 가장 큰 노드를 선택한다.&lt;/p&gt;
&lt;h3 id=&quot;4-markov-decision-processes&quot;&gt;4. &lt;a href=&quot;https://en.wikipedia.org/wiki/Markov_decision_process&quot;&gt;Markov Decision Processes&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;다음 state는 오직 현재 state에 의해서만 영향을 받는다(Simplified version of the world). 즉, 미래와 과거가 독립이라는 것을 가정한다. 보상 R(s, a, s’) / Transition function T(s, a, s’) = P(s’|s, a)&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Value Iteration
&lt;img src=&quot;https://wikimedia.org/api/rest_v1/media/math/render/svg/642146ac65c7d64f99f1a77ffdff3397b555068e&quot; /&gt;
Complexity - O(S^2A)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Bellman_equation&quot;&gt;Bellman Equations&lt;/a&gt;: a Bellman equation is a recursion for expected rewards.
    &lt;h3 id=&quot;value-iteration의-문제점&quot;&gt;Value Iteration의 문제점&lt;/h3&gt;
    &lt;p&gt;V function에는 optimal action이 포함되지 않음. 수렴하는데 오래 걸림. =&amp;gt; Policy Iteration: action을 track하지 않아도 돼서 시간이 적게 걸림(Value iteration 둘다 one-step lookahead 개념 활용) &lt;br /&gt;
Q value를 활용하면 action을 선택하기 쉬워짐&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;regret = u(possible action) - u(action taken)
it converges to 0 if the strategy is good enough&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;mdp-아닌-경우model-free-문제점&quot;&gt;MDP 아닌 경우(Model-free) 문제점&lt;/h3&gt;
&lt;p&gt;In reinforcement learning (RL), a model-free algorithm (as opposed to a model-based one) is an algorithm which does not use the transition probability distribution (and the reward function) associated with the Markov decision process (MDP)   &lt;br /&gt;
R, T를 모름&lt;/p&gt;
&lt;h4 id=&quot;해결책-q-learning&quot;&gt;해결책: Q-Learning&lt;/h4&gt;
&lt;p&gt;Q-values를 활용: action을 선택하고 그에 따른 reward에 맞춰서 Q-value를 업데이트 해줌.
&lt;img src=&quot;https://wikimedia.org/api/rest_v1/media/math/render/svg/678cb558a9d59c33ef4810c9618baf34a9577686&quot; /&gt;&lt;/p&gt;
&lt;h3 id=&quot;q-learning의-문제점&quot;&gt;Q-Learning의 문제점&lt;/h3&gt;
&lt;p&gt;비슷한 노드끼리 서로 다르게 보기 때문에 탐색과정을 일일이 거쳐야 한다는 단점. 따라서 feature를 이용해서 state를 일반화해주는 것이 가능하다. =&amp;gt; Feature-Based Representation &amp;amp; Approximate Q-Learning&lt;/p&gt;

&lt;h3 id=&quot;5-naive-bayes-및-확률-기초-개념-정리&quot;&gt;5. Naive Bayes 및 확률 기초 개념 정리&lt;/h3&gt;
&lt;p&gt;1) random variable - 확률적인 과정에 따라 값이 결정되는 변수(오메가 -&amp;gt; E로의 mapping)  &lt;br /&gt;
2) 조건부 확률 - 주어진 사건이 일어났다는 가정 하에 다른 한 사건이 일어날 확률을 뜻한다.  &lt;br /&gt;
3) &lt;a href=&quot;https://en.wikipedia.org/wiki/Chain_rule_(probability)&quot;&gt;Chain rule&lt;/a&gt;  &lt;br /&gt;
4) &lt;a href=&quot;https://en.wikipedia.org/wiki/Bayes%27_theorem&quot;&gt;Bayes Theorem&lt;/a&gt;   &lt;br /&gt;
5) &lt;a href=&quot;https://en.wikipedia.org/wiki/Maximum_likelihood_estimation&quot;&gt;MLE&lt;/a&gt;    &lt;br /&gt;
6) &lt;a href=&quot;https://en.wikipedia.org/wiki/Maximum_a_posteriori_estimation&quot;&gt;MAP&lt;/a&gt;    &lt;br /&gt;
7) 조건부 독립 - p(a|b,c)=p(a|c), 즉 b, c가 있거나 없거나 a의 확률에 영향을 미치지 않는다.
8) Naive Bayes- 조건부 독립을 가정하면 c의 prior와 c와 다른 사건의 조건부 확률의 곱 또는 log합으로 나타낼 수 있다.   &lt;br /&gt;
장점은 단순하고 빠르다는 것이 있으나 independent하지 않을 경우 bias 문제에 빠질 수 있으며 pattern을 모델링 할 수 없다는 문제가 있다. 따라서 정확도도 낮은 편이다.&lt;/p&gt;

&lt;h3 id=&quot;6-기계학습-정리&quot;&gt;6. 기계학습 정리&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Overfitting 방지를 위한 regularization term 추가&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Backpropagation&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;A support vector machine (SVM) is a supervised machine learning model that uses classification algorithms for two-group classification problems. After giving an SVM model sets of labeled training data for each category, they’re able to categorize new text.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Kernel Trick - Kernel function(similarity function)은 높은 차원의 내적을 의미한다. K(x_i,x_j)로 구성된 행렬은 positive semi-definite matrix여야 하며 대칭행렬(symetric matrix)이어야 합니다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;PCA - eigenvalue decomposition of covariance matrices&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;7-딥러닝&quot;&gt;7. 딥러닝&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;CNN - In deep learning, a convolutional neural network (CNN, or ConvNet) is a class of deep neural networks, most commonly applied to analyzing visual imagery.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;RNN - A recurrent neural network (RNN) is a class of artificial neural networks where connections between nodes form a directed graph along a temporal sequence.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content>

      
      
      
      
      

      <author>
          <name>Park Seung Joon</name>
        
        
      </author>

      

      
        <category term="interview" />
      

      
        <summary type="html">면접 대비를 위해서 정리한 내용을 간단히 써보고자 한다.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">IO speed - 입출력 속도 비교 및 자바 입출력 방법</title>
      <link href="http://localhost:4000/IO" rel="alternate" type="text/html" title="IO speed - 입출력 속도 비교 및 자바 입출력 방법" />
      <published>2020-08-12T23:30:00+09:00</published>
      <updated>2020-08-12T23:30:00+09:00</updated>
      <id>http://localhost:4000/IO</id>
      <content type="html" xml:base="http://localhost:4000/IO">&lt;p&gt;오늘은 간단히 입출력 방법에 대해 정리해보고자 한다.&lt;/p&gt;

&lt;p&gt;알고리즘 문제를 풀다보면 입출력으로 인해 시간 초과가 발생하는 경우가 있다.   &lt;br /&gt;
백준 사이트에서 입출력 속도를 비교한 것을 보고 어떤 입출력을 사용하는 것이 속도 측면에서 나은지 살펴보자.  &lt;br /&gt;
&lt;a href=&quot;https://www.acmicpc.net/blog/view/56&quot;&gt;입력 속도 비교&lt;/a&gt; / &lt;a href=&quot;https://www.acmicpc.net/blog/view/57&quot;&gt;출력 속도 비교&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;입력&quot;&gt;입력&lt;/h3&gt;
&lt;p&gt;입력은 자바 기준으로 Scanner보다 BufferedReader와 Integer.parseInt를 사용하는게 약 7배 빠른 것을 알 수 있다.  &lt;br /&gt;
문제 풀이를 위한 한 줄 라인 입력은 아래와 같이 받을 수 있다.&lt;/p&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;BufferedReader&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;br&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;BufferedReader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;inputStreamReader&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;in&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 한 줄에 integer input 하나인 경우&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;input&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;parseInt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;br&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;readLine&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// 한 줄에 여러 input이 공백을 구분자로 두고 있는 경우&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;StringTokenizer&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;st&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;StringTokenizer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;br&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;readLine&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;number1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Integer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;parseInt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;st&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;nextToken&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;출력&quot;&gt;출력&lt;/h3&gt;
&lt;p&gt;출력은 BufferedWriter를 쓰는것이 System.out.println(sb)을 쓰는 것보다 빠르나 차이가 미미하기 때문에 조금 더 편리한 System.out.println(sb)를 사용하는게 좋겠다.&lt;/p&gt;

&lt;h3 id=&quot;c의-경우&quot;&gt;C++의 경우&lt;/h3&gt;
&lt;p&gt;C++은 출력에서 cout « i « endl을 사용할 경우 시간 초과가 날 수 있다. &lt;code class=&quot;highlighter-rouge&quot;&gt;endl&lt;/code&gt;대신 &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;\n&quot;&lt;/code&gt;을 이용하자.    &lt;br /&gt;
C++에서 빠른 입출력을 원할 경우 C 표준 입출력을 동기화하는 &lt;code class=&quot;highlighter-rouge&quot;&gt;ios_bas::sync_with_stdio(false);&lt;/code&gt; 설정을 해주고 &lt;code class=&quot;highlighter-rouge&quot;&gt;cin.tie(null);&lt;/code&gt;을 통해 cin과 cout을 분리해준다. 물론 그냥 C의 표준입출력 scanf/printf를 사용해도 된다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Park Seung Joon</name>
        
        
      </author>

      

      
        <category term="algorithm" />
      
        <category term="java" />
      

      
        <summary type="html">오늘은 간단히 입출력 방법에 대해 정리해보고자 한다.</summary>
      

      
      
    </entry>
  
</feed>
