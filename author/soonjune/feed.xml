<?xml version="1.0" encoding="utf-8"?>

<feed xmlns="http://www.w3.org/2005/Atom" >
  <generator uri="https://jekyllrb.com/" version="3.7.4">Jekyll</generator>
  <link href="https://soonjune.github.io/author/soonjune/feed.xml" rel="self" type="application/atom+xml" />
  <link href="https://soonjune.github.io/" rel="alternate" type="text/html" />
  <updated>2021-01-12T18:41:30+09:00</updated>
  <id>https://soonjune.github.io/author/soonjune/feed.xml</id>

  
  
  

  
    <title type="html">Seung Joon’s Blog | </title>
  

  
    <subtitle>Personal Blog of Park Seung Joon</subtitle>
  

  

  
    
      
    
  

  
  

  
    <entry>
      <title type="html">Number Systems and Boolean Algebra</title>
      <link href="https://soonjune.github.io/number-system-and-boolean-algebra" rel="alternate" type="text/html" title="Number Systems and Boolean Algebra" />
      <published>2021-01-09T20:00:00+09:00</published>
      <updated>2021-01-09T20:00:00+09:00</updated>
      <id>https://soonjune.github.io/number-system-and-boolean-algebra</id>
      <content type="html" xml:base="https://soonjune.github.io/number-system-and-boolean-algebra">&lt;p&gt;데이터사이언스대학원 Bootcamp 6일차 데이터사이언스를 위한 컴퓨터 시스템 강의 공부한 내용을 정리해본다.
&lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML&quot;&gt;
&lt;/script&gt;&lt;/p&gt;

&lt;h3 id=&quot;1-number-systems&quot;&gt;1. Number Systems&lt;/h3&gt;
&lt;p&gt;컴퓨터는 알다시피 데이터를 0과 1의 조합으로 표현한다. 이진수를 사용하는 이유는 높은 전압과 낮은 전압으로 표현이 가능하기 때문이다. 0, 1 이외의 다른 값이 존재한다면 모호성이 높아질 수밖에 없다. 컴퓨터에서는 2의 보수를 사용해서 연산을 하는데 그 이유는 효율성과 관련이 있다.&lt;/p&gt;

&lt;h4 id=&quot;보수raidx-complement&quot;&gt;보수(raidx complement)&lt;/h4&gt;
&lt;p&gt;r-진법으로 표현된 n개의 자리를 가진 수 x의 보수는 x가 0일 경우 0, 0이 아닐 경우 &lt;script type=&quot;math/tex&quot;&gt;r^n - x&lt;/script&gt;로 정의한다.
x의 (r-1)의 보수(diminished radix complement)는 &lt;script type=&quot;math/tex&quot;&gt;(r^n - 1) - x&lt;/script&gt;로 정의한다. 따라서 1의 보수를 2의 보수로 만들기 위해서는 1을 더해주면 된다.&lt;/p&gt;

&lt;p&gt;1의 보수는 이진법으로 표현한 원래 숫자의 단순 bit flip으로 구할 수 있다. 이 때 0이 되는 경우가 2가지 나오기 때문에(모든 숫자가 0 또는 모든 숫자가 1) 2의 보수를 사용해서 하드웨어로 구현한다.&lt;/p&gt;

&lt;h3 id=&quot;2-boolean-algebra-and-logic-gates&quot;&gt;2. Boolean Algebra and Logic Gates&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/First-order_logic&quot;&gt;First-order logic&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;함수적 완전성(Functional Completeness): 어떤 Boole 연산의 집합이 함수적으로 완전하다라는 뜻은 주어진 입력 변수의 집합에 대하여 그 집합에 속한 연산들로 모든 서로 다른 Boole 함수를 정의할 수 있을을 뜻한다. 함수적 완전성을 만족하는 연산의 기본적인 집합은 {AND, OR, NOT}이다. {NOR}와 {NAND}도 각각 AND, OR, NOT을 implement할 수 있기 때문에 함수적으로 완전하다.  &lt;br /&gt;
논리 설계시 NAND나 NOR 게이트 사용을 선호하는데 AND, OR, NOT을 각각 구현하는 것보다 transistor가 더 적게 들어가기 때문이다.&lt;/li&gt;
  &lt;li&gt;논리 게이트(Logic Gate)는 Boole 연산을 그림으로 나타낼 수 있게 한다.&lt;/li&gt;
&lt;/ul&gt;</content>

      
      
      
      
      

      <author>
          <name>Park Seung Joon</name>
        
        
      </author>

      

      
        <category term="computer-system" />
      

      
        <summary type="html">데이터사이언스대학원 Bootcamp 6일차 데이터사이언스를 위한 컴퓨터 시스템 강의 공부한 내용을 정리해본다.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Matrix Decompositions</title>
      <link href="https://soonjune.github.io/matrix-decompositions" rel="alternate" type="text/html" title="Matrix Decompositions" />
      <published>2021-01-09T20:00:00+09:00</published>
      <updated>2021-01-09T20:00:00+09:00</updated>
      <id>https://soonjune.github.io/matrix-decompositions</id>
      <content type="html" xml:base="https://soonjune.github.io/matrix-decompositions">&lt;p&gt;데이터사이언스대학원 Bootcamp 4일차 수업은 4장 Matrix Decomposition을 공부했다. 선형대수의 핵심적 개념인 &lt;a href=&quot;https://en.wikipedia.org/wiki/Eigenvalues_and_eigenvectors#:~:text=In%20linear%20algebra%2C%20an%20eigenvector,which%20the%20eigenvector%20is%20scaled.&quot;&gt;eigenvalue와 eigenvector&lt;/a&gt;가 나오므로 잘 알아두는 게 중요하다.&lt;/p&gt;

&lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML&quot;&gt;
&lt;/script&gt;

&lt;h3 id=&quot;41-determinant-and-trace&quot;&gt;4.1 Determinant and Trace&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Determinant&quot;&gt;Determinant&lt;/a&gt;는 square matrix에 대해서만 정의되며 &lt;a href=&quot;https://en.wikipedia.org/wiki/Laplace_expansion&quot;&gt;Laplace Expansion&lt;/a&gt;을 통해 구할 수 있다. 역행렬의 존재여부를 확인하고 구하거나 n-dimensional 평행육면체의 부피를 구하는 등에 쓰인다.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Trace_(linear_algebra)&quot;&gt;Trace&lt;/a&gt;는 diagonal elements의 합이다. 두 행렬이 각각 n X k, k X n이라면 교환법칙이 성립하기 때문에 cyclic permutation에 대해 invariant하다.&lt;/p&gt;

&lt;h3 id=&quot;42-eigenvalues-and-eigenvectors&quot;&gt;4.2 Eigenvalues and Eigenvectors&lt;/h3&gt;
&lt;p&gt;행렬 A의 eigenvalue와 eigenvector를 구하는 방법을 알아보자. 우선 &lt;a href=&quot;https://en.wikipedia.org/wiki/Characteristic_polynomial&quot;&gt;charateristic polynomial&lt;/a&gt;을 solve해서 λ를 구한다. 이때 구해지는 λ가 eigenvalue들이 된다. 특정 λ에 대해 (A-λI)x = O를 풀어서 구한 벡터 x들이 eigenvectors가 되며 이들의 span이 eigenspace가 된다.&lt;/p&gt;

&lt;h3 id=&quot;44-eigendecomposition-and-diagonalization&quot;&gt;4.4 Eigendecomposition and Diagonalization&lt;/h3&gt;
&lt;p&gt;Diagonal matrix D는 &lt;script type=&quot;math/tex&quot;&gt;D = P^{-1}AP&lt;/script&gt;과 같이 invertible matrix P를 이용해서 나타낼수 있는 행렬을 의미한다. 이때, A와 D는 닮음 관계에 있다고 한다. 식을 다시 표현하면 AP = PD로 나타낼 수 있는데 이는 eignevalue와 eigenvector를 정의할 때 보았던 식과 유사하다. 즉, 우리는 A를 &lt;script type=&quot;math/tex&quot;&gt;PDP^{-1}&lt;/script&gt; 꼴로 나타낼 수 있는데 이를 eigendecomposition이라고 한다. D는 entry(대각선 값)들이 eigenvalue이고 P는 그에 상응하는 eigenvector들이 column vector인 행렬이다. P는 full rank인 square matrix여야 한다. 이는 eigenvector들이 모두 선형독립이라는 말과 동치이다.&lt;/p&gt;

&lt;p&gt;Orthormal Basis B의 역행렬은 transopose와 같다는 점이 eigendecomposition할 때 유용하게 쓰일 수 있다. 우선 하나의 eigenvector를 이용해서 Gram–Schmidt process를 수행하면 서로 orthornormal한 벡터들을 얻을 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;45-singular-value-decomposition&quot;&gt;4.5 &lt;a href=&quot;https://en.wikipedia.org/wiki/Singular_value_decomposition&quot;&gt;Singular Value Decomposition&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;square matrix가 아닌 행렬도 분해해서 차원을 축소해서 나타낼수 있다. Eigendecompostion의 일반화된 버전으로 볼 수 있기에 SVD는 특정 행렬에 대해 항상 가능하다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Park Seung Joon</name>
        
        
      </author>

      

      
        <category term="linear-algebra" />
      
        <category term="math" />
      

      
        <summary type="html">데이터사이언스대학원 Bootcamp 4일차 수업은 4장 Matrix Decomposition을 공부했다. 선형대수의 핵심적 개념인 eigenvalue와 eigenvector가 나오므로 잘 알아두는 게 중요하다.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Analytic Geometry</title>
      <link href="https://soonjune.github.io/analytic-geometry" rel="alternate" type="text/html" title="Analytic Geometry" />
      <published>2021-01-07T20:00:00+09:00</published>
      <updated>2021-01-07T20:00:00+09:00</updated>
      <id>https://soonjune.github.io/analytic-geometry</id>
      <content type="html" xml:base="https://soonjune.github.io/analytic-geometry">&lt;p&gt;데이터사이언스대학원 Bootcamp 3일차에는 교재의 해석기하학 챕터(Chapter 3)를 다뤘다. 이번 장에서는 앞서 배운 내용들에 대한 기하학적 해석들을 살펴본다. Geometric vector를 이용해서 길이, 거리, 두 벡터간 각도를 계산할 수 있는데, 이를 위해서 아래 내용들부터 살펴보자.&lt;/p&gt;

&lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML&quot;&gt;
&lt;/script&gt;

&lt;h3 id=&quot;31-norms&quot;&gt;3.1 Norms&lt;/h3&gt;
&lt;p&gt;Norm은 벡터 공간을 input으로 하고 output으로 음이 아닌 실수를 내뱉는 함수이다.
&lt;a href=&quot;https://en.wikipedia.org/wiki/Norm_(mathematics)#Definition&quot;&gt;링크&lt;/a&gt;에 나온의 세가지 조건을 만족해야 한다. 대표적으로 l1-norm과 l2-norm이 있는데 l2-norm은 Euclidean distance라고 부르기도 한다.&lt;/p&gt;

&lt;h3 id=&quot;32-inner-products&quot;&gt;3.2 Inner Products&lt;/h3&gt;
&lt;p&gt;벡터의 길이 또는 두 벡터 사이의 각도에 대한 직관적인 이해를 위해서 inner product 개념이 활용된다. Inner product로 두 벡터가 서로 orthogonal한지 확인할 수 있다. 우선 inner product의 대표격인 dot product부터 살펴보자.&lt;/p&gt;

&lt;h4 id=&quot;321-dot-product&quot;&gt;3.2.1 Dot Product&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Dot_product#Complex_vectors&quot;&gt;Dot product&lt;/a&gt; 또는 스칼라곱은 유클리드 공간의 두 벡터로부터 실수 스칼라를 얻는 연산이다.&lt;/p&gt;

&lt;h4 id=&quot;322-general-inner-products&quot;&gt;3.2.2 General Inner Products&lt;/h4&gt;
&lt;p&gt;먼저, linear mapping 개념에 더해서 &lt;a href=&quot;https://en.wikipedia.org/wiki/Bilinear_map&quot;&gt;bilinear mapping&lt;/a&gt; 개념을 살펴본다. Bilinear map은 두개의 벡터 공간을 input으로 받아 새로운 벡터 공간을 뱉어내는 함수이다.&lt;/p&gt;

&lt;h5 id=&quot;symmetric&quot;&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Symmetric_function&quot;&gt;Symmetric&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;교환에 대하여 불변&lt;/p&gt;

&lt;h5 id=&quot;positive-definite&quot;&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Positive_definiteness&quot;&gt;Positive definite&lt;/a&gt;&lt;/h5&gt;
&lt;p&gt;0 벡터를 제외한 벡터 공간을 input으로 해서 같은 벡터로 bilinear mapping을 해서 항상 0보다 크면 bilinear map은 positive definite이다. 두개 argument 모두 영벡터인 경우에만 0이 나온다.&lt;/p&gt;

&lt;p&gt;최종적으로 일반적인 &lt;a href=&quot;https://en.wikipedia.org/wiki/Inner_product_space&quot;&gt;inner product&lt;/a&gt;는 positive definite, symmetric한 bilinear mapping으로 같이 정의할 수 있다.&lt;/p&gt;

&lt;h4 id=&quot;323-symmetric-positive-definite-matriceshttpsenwikipediaorgwikidefinite_symmetric_matrix&quot;&gt;3.2.3 Symmetric, Positive (Definite Matrices)[https://en.wikipedia.org/wiki/Definite_symmetric_matrix]&lt;/h4&gt;
&lt;p&gt;n X n 실수 행렬 A가 symmetric, postive definite이고 &amp;lt;x, y&amp;gt; = &lt;script type=&quot;math/tex&quot;&gt;x̂^TAŷ&lt;/script&gt;이면 벡터 공간 V와 V의 ordered basis B에 대하여 &amp;lt;·,·&amp;gt;: V x V → R은 inner product이다. x̂(x hat)과 ŷ(y hat)은 basis B에 대한 x, y 좌표이다.&lt;/p&gt;

&lt;h3 id=&quot;33-lengths-and-distances&quot;&gt;3.3 Lengths and Distances&lt;/h3&gt;
&lt;p&gt;길이는 inner product에 루트를 씌어준 것, 즉 norm으로 정의할 수 있다. 하지만 모든 norm이 inner product로 유도되는 것은 아니라는 점에 유의하자. Inner product에 따라서 길이가 달라질 수 있다. 두 벡터 간 거리는 두 벡터를 뺀 것의 norm으로 정의할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;34-angles-and-orthogonality&quot;&gt;3.4 Angles and Orthogonality&lt;/h3&gt;
&lt;p&gt;두 subspace 간 &lt;a href=&quot;https://en.wikipedia.org/wiki/Angles_between_flats#:~:text=Advanced%20properties,-Non%2Dtrivial%20(different&amp;amp;text=)%20angles%20between%20two%20subspaces%20are,angles%20between%20their%20orthogonal%20complements.&amp;amp;text=The%20angles%20between%20subspaces%20satisfy,set%20into%20a%20metric%20space&quot;&gt;각도&lt;/a&gt;는 inner product를 이용해서 정의할 수 있다. 각도는 방향이 얼마나 유사한지를 나타낸다. 비슷할 수록 각도는 0에 가깝다.&lt;/p&gt;

&lt;p&gt;두 벡터를 argument로 하는 inner product가 0 일 때 orthogonal하다고 한다. 특별히 두 벡터의 norm이 1인 경우는 orthonormal하다고 한다.&lt;/p&gt;

&lt;p&gt;Orthogonal Matrix는 transpose와 곱해서 identity matrix가 나오는 square matrix로 정의한다. 이는 &lt;script type=&quot;math/tex&quot;&gt;A^T = A^{-1}&lt;/script&gt;을 의미한다.&lt;/p&gt;

&lt;h3 id=&quot;35-orthonormal-basis&quot;&gt;3.5 Orthonormal Basis&lt;/h3&gt;
&lt;p&gt;n-dimensional vector space에서 n개의 basis 벡터들이 서로 orthogonal하고 길이가 1인 경우이다.&lt;/p&gt;

&lt;h3 id=&quot;36-orthogonal-complement&quot;&gt;3.6 Orthogonal Complement&lt;/h3&gt;
&lt;p&gt;D-dimensional vector space V는 M-dimensional subspace U와 그 (D-M)-dimensional orthogonal complement로 나타낼 수 있다. U와 그 orthogonal complement의 교집합의 원소는 영벡터 뿐이다.&lt;/p&gt;

&lt;h3 id=&quot;38-orthogonal-projections&quot;&gt;3.8 Orthogonal Projections&lt;/h3&gt;
&lt;p&gt;앞서 vector space V를 어떤 subspace U와 그 orthogonal complement로 표현할 수 있다는 것을 알았다. 이를 이용해서 V에 속하는 벡터 x를 U에 projection할 수 있다. U의 ordered basis B와 B의 각 원소의 coordinate을 표현하는 λ를 행렬곱하면 x를 projection한 결과를 얻을 수 있다. 우리가 관심 있는 부분은 λ이다. &lt;script type=&quot;math/tex&quot;&gt;B^T&lt;/script&gt;(x - Bλ) = 0&lt;script type=&quot;math/tex&quot;&gt;이 되는 λ를 찾으면 된다. B의 역행렬이 존재한다면 λ =&lt;/script&gt;(B^TB)^{-1}&lt;script type=&quot;math/tex&quot;&gt;&lt;/script&gt;B^Tx&lt;script type=&quot;math/tex&quot;&gt;로 나타낼 수 있다. B의 column들은 모두 linearly independent 하기 때문에&lt;/script&gt;B^TB$$의 역행렬이 존재한다. 따라서 λ를 구할 수 있다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Park Seung Joon</name>
        
        
      </author>

      

      
        <category term="math" />
      

      
        <summary type="html">데이터사이언스대학원 Bootcamp 3일차에는 교재의 해석기하학 챕터(Chapter 3)를 다뤘다. 이번 장에서는 앞서 배운 내용들에 대한 기하학적 해석들을 살펴본다. Geometric vector를 이용해서 길이, 거리, 두 벡터간 각도를 계산할 수 있는데, 이를 위해서 아래 내용들부터 살펴보자.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Vector Spaces and Linear Independence</title>
      <link href="https://soonjune.github.io/vector-spaces-and-linear-independence" rel="alternate" type="text/html" title="Vector Spaces and Linear Independence" />
      <published>2021-01-06T20:00:00+09:00</published>
      <updated>2021-01-06T20:00:00+09:00</updated>
      <id>https://soonjune.github.io/vector-spaces-and-linear-independence</id>
      <content type="html" xml:base="https://soonjune.github.io/vector-spaces-and-linear-independence">&lt;p&gt;데이터사이언스대학원 Bootcamp 2일차에는 벡터 공간(Vector space)와 선형 독립(Linear Independence)을 주로 다뤘다. 들어가기에 앞서, 저번 시간에 배웠던 연립 일차 방정식을 풀기 위한 elementary transformation에 대해 잠깐 살펴보자. Elementray row/column operations은 elementary matrix를 우측 또는 좌측에 곱함으로써 수행할 수 있다.(&lt;a href=&quot;https://en.wikipedia.org/wiki/Elementary_matrix#:~:text=From%20Wikipedia%2C%20the%20free%20encyclopedia,when%20R%20is%20a%20field.&quot;&gt;Elementary Matrix&lt;/a&gt;) 기본행연산에는 3가지가 있는데 아래와 같다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;두 row를 바꾼다 (swap)&lt;/li&gt;
  &lt;li&gt;row에 0이 아닌 상수를 곱한다.&lt;/li&gt;
  &lt;li&gt;두 row를 더한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;위 세가지 operation은 solution에 영향을 끼치지 않는다. 따라서 이들 연산을 이용해서 행렬을 reduced echelon form(계단 모양으로 나타난다)으로 바꿔 해를 구한다.&lt;/p&gt;

&lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML&quot;&gt;
&lt;/script&gt;

&lt;h3 id=&quot;233-the-minus-1-trick&quot;&gt;2.3.3 The Minus-1 Trick&lt;/h3&gt;
&lt;p&gt;행렬 A가 k X n이라면 reduced echeolon form으로 만든 뒤 n X n으로 만들어 주기 위해서 n - k row를 추가한다. 이 때 pivot이 없는 대각선 부분을 -1로 만들어주기 위해 row를 해당 부분에 추가한다. 이 때 -1이 있는 부분의 column을 이용해서 Homogeneous system&lt;sup&gt;&lt;a href=&quot;#footnote_1&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;의 바로 해를 찾을 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;234-algorithms-for-solving-a-system-of-linear-equations&quot;&gt;2.3.4 Algorithms for Solving a System of Linear Equations&lt;/h3&gt;
&lt;p&gt;Gaussian elimination은 아래 상황에서 모두 사용되기에 매우 유용하다.
(1) determinant를 계산
(2) 선형 독립 여부 확인
(3) 역행렬 연산
(4) rank 계산
(3) 벡터 공간의 basis 구하기&lt;/p&gt;

&lt;p&gt;하지만 효율성을 위해서 실용적으로는 어느 정도의 오차를 감안하고 iterative한 방법이 활용되고 있다.&lt;/p&gt;

&lt;h3 id=&quot;24-vector-spaces&quot;&gt;2.4 Vector Spaces&lt;/h3&gt;
&lt;h4 id=&quot;241-groups&quot;&gt;2.4.1 Groups&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/Group_(mathematics)&quot;&gt;Group&lt;/a&gt; 정의.&lt;/p&gt;

&lt;p&gt;n X n 행렬에 대해서도 행렬의 곱셈 정의에 따라 결합법칙이 성립하고 살수 n X n 행렬에 대해 닫혀 있다. 항등원 I가 존재하고 역행렬이 존재할 경우 위에서 정의한 group애 해당한다. 이를 general linear group이라고 부른다.&lt;/p&gt;

&lt;h4 id=&quot;242-vector-spaces&quot;&gt;2.4.2 Vector Spaces&lt;/h4&gt;
&lt;p&gt;V는 집합니다. 이 집합의 원소를 벡터라고 한다. Real-valued vector space V = (V, +, ·)은 아래 두 연산을 갖는 집합이다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;ul&gt;
      &lt;li&gt;: 벡터 덧셈&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;· : 스칼라 곱셈
벡터간 곱셈은 정의되지 않았음에 유의하자.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;243-vector-subspaces&quot;&gt;2.4.3 Vector Subspaces&lt;/h4&gt;
&lt;p&gt;Vector space에 contained된 space. Vector space가 지닌 특성들을 모두 inherit한다. Vector subspace는 closure 조건을 만족시켜야 하며 덧셈에 대한 항등원인 0을 포함해야 한다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Vector subspace 간 교집합도 vector subspace이다. (&lt;a href=&quot;https://yutsumura.com/the-intersection-of-two-subspaces-is-also-a-subspace/#:~:text=To%20prove%20that%20the%20intersection,x%E2%88%88U%E2%88%A9V.&quot;&gt;증명&lt;/a&gt;)&lt;/li&gt;
  &lt;li&gt;Ax = O의 solution x가 항상 &lt;script type=&quot;math/tex&quot;&gt;R^n&lt;/script&gt;의 subspace이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;25-linear-independence&quot;&gt;2.5 Linear Independence&lt;/h4&gt;
&lt;p&gt;키워드: &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EC%84%A0%ED%98%95_%EA%B2%B0%ED%95%A9&quot;&gt;선형 결합&lt;/a&gt;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Linear_independence#:~:text=In%20the%20theory%20of%20vector,said%20to%20be%20linearly%20independent.&quot;&gt;선형독립&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;선형결합은 Vector space에 있는 유한한 수의 벡터들과 상수배를 이용해서 vector space 내 다른 벡터 v를 나타내는 방법. 선형독립은 선형결합으로 영벡터를 나타내는 방법이 오직 상수(람다)를 모두 0으로 해야만 하는 경우이다.&lt;/p&gt;

&lt;p&gt;Echelon form으로 나타냈을 때 모든 column이 pivot column일 경우에만 선형독립이다(필요충분)&lt;/p&gt;

&lt;h3 id=&quot;26-basis-and-rank&quot;&gt;2.6 Basis and Rank&lt;/h3&gt;
&lt;h4 id=&quot;261-generating-set-and-basis&quot;&gt;2.6.1 Generating Set and Basis&lt;/h4&gt;
&lt;p&gt;Generating set은 Vector Space V에 속하는 벡터 v가 유한(k)개의 벡터로 나타낼 수 있으면 이 벡터들의 집합 A를 generating set이라고 한다. Generating set A를 가지고 만들 수 있는 모든 선형결합의 집합을 span of A라고 정의한다.&lt;/p&gt;

&lt;p&gt;Basis는 Vector space V의 가장 작은 generating set이다. 가장 작다는 것은 해당 generating set보다 더 작은 generating set의 조건을 만족하는 집합이 없음을 의미한다. Generating set의 선형독립인 vector들을 V의 basis라고 부른다.&lt;/p&gt;

&lt;p&gt;Basis는 unique하지 않지만 벡터 수는 같다. 이때 vector space의 차원은 basis 벡터의 수와 같다. basis를 이용해서 vector space 내 다른 vector를 표현할 때의 해는 유일하다.&lt;/p&gt;

&lt;h4 id=&quot;262-rank&quot;&gt;2.6.2 Rank&lt;/h4&gt;
&lt;p&gt;행렬 내에 independent한 행 또는 열의 수를 rank라고 한다.&lt;/p&gt;

&lt;h3 id=&quot;27-linear-mappings&quot;&gt;2.7 Linear Mappings&lt;/h3&gt;
&lt;p&gt;벡터 공간의 성질을 만족시키기 위해서 mapping할 때 특정 성질을 만족하는 경우 linear mapping이라고 한다. Linear mapping을 행렬로 표현할 수 있다.&lt;/p&gt;

&lt;p&gt;Image와 Kernel(또는 Null Space)은 다음과 같이 정의한다. Kernel은 영행렬이 나오게끔하는 정의역 내 벡터들의 집합. Image는 치역으로 볼 수 있다.&lt;/p&gt;

&lt;p&gt;(&lt;a href=&quot;https://brilliant.org/wiki/rank-nullity-theorem/#:~:text=The%20rank%2Dnullity%20theorem%20states,columns%20over%20a%20field%2C%20then&quot;&gt;Rank-Nullity Theorem&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;&lt;a name=&quot;footnote_1&quot;&gt;1&lt;/a&gt;: A system of linear equations is homogeneous if all of the constant terms are zero&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Park Seung Joon</name>
        
        
      </author>

      

      
        <category term="linear-algebra" />
      
        <category term="math" />
      

      
        <summary type="html">데이터사이언스대학원 Bootcamp 2일차에는 벡터 공간(Vector space)와 선형 독립(Linear Independence)을 주로 다뤘다. 들어가기에 앞서, 저번 시간에 배웠던 연립 일차 방정식을 풀기 위한 elementary transformation에 대해 잠깐 살펴보자. Elementray row/column operations은 elementary matrix를 우측 또는 좌측에 곱함으로써 수행할 수 있다.(Elementary Matrix) 기본행연산에는 3가지가 있는데 아래와 같다.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Mathematics for Machine Learning</title>
      <link href="https://soonjune.github.io/Linear-Algebra" rel="alternate" type="text/html" title="Mathematics for Machine Learning" />
      <published>2021-01-05T20:00:00+09:00</published>
      <updated>2021-01-05T20:00:00+09:00</updated>
      <id>https://soonjune.github.io/Linear-Algebra</id>
      <content type="html" xml:base="https://soonjune.github.io/Linear-Algebra">&lt;p&gt;서울대 데이터사이언스대학원 Bootcamp를 수강하면서 배운 내용을 정리해보고자 한다. 1주차에는 데이터사이언스를 위한 수학을 주제로 오민환 교수님께서 강의를 진행했다. 교재는 &lt;a href=&quot;https://mml-book.github.io/book/mml-book.pdf&quot;&gt;Mathematics for Machine Learning&lt;/a&gt;이라는 오픈 소스 교재를 사용하였다. 오늘은 Ch2까지 배운 선형대수의 기초적인 내용을 정리해본다.&lt;/p&gt;

&lt;h3 id=&quot;i-책-소개-intro&quot;&gt;I. 책 소개 (Intro)&lt;/h3&gt;
&lt;p&gt;교재에서는 머신러닝을 위한 기초적인 지식으로 3가지롤 꼽고 있다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;프로그래밍 언어 및 데이터 분석 도구&lt;/li&gt;
  &lt;li&gt;대규모 컴퓨팅 및 그와 관련된 프레임워크&lt;/li&gt;
  &lt;li&gt;수학, 통계 지식
이 책에서는 마지막 부분, 즉 수학과 연관된 부분을 다룬다. 모델 자체의 알고리즘에 초점을 맞추기보다는 수학적인 개념과 실용적인 궁금증을 해결하고자 노력했다고 저자는 밝히고 있다.
    &lt;h4 id=&quot;핵심-단어-데이터data-모델model-학습learning&quot;&gt;핵심 단어: 데이터(data), 모델(model), 학습(learning)&lt;/h4&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML&quot;&gt;
&lt;/script&gt;

&lt;h3 id=&quot;ii-선형대수-linear-algebra&quot;&gt;II. 선형대수 (Linear Algebra)&lt;/h3&gt;
&lt;p&gt;(1) Geometric vectors / Polynomials =&amp;gt; They are both vectors. Audio signals, elements of &lt;script type=&quot;math/tex&quot;&gt;R^n&lt;/script&gt; are vectors.
(2) Closure(닫힘) - 그 집합의 원소와 관계가 있는 원소가 항상 그 집합에 속한다는 성질이다.
&lt;img src=&quot;https://miro.medium.com/max/4800/1*5haUfmOWQUh9N353hMy9KQ.png&quot; alt=&quot;mind-map&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;21-연립-일차-방정식-systems-of-linear-equations&quot;&gt;2.1 연립 일차 방정식 (Systems of Linear Equations)&lt;/h3&gt;
&lt;p&gt;해는 없거나 / 하나만 존재하거나 / 무수히 많을 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;22-행렬-matrices&quot;&gt;2.2 행렬 (Matrices)&lt;/h3&gt;
&lt;p&gt;연립 일차 방정식을 행렬을 이용해서 간결하게 표현할 수 있다. &lt;br /&gt;
행렬은 또한 선형 변환(Linear mapping)이라는 함수를 표현할 수 있다. &lt;br /&gt;
행렬의 덧셈과 곱셈 정의. 곱셈에 대하여 교환법칙이 성립하지 않는다.&lt;/p&gt;

&lt;p&gt;cf . 아인슈타인 표기법
np.einsum을 이용해서 나타낼 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;222-역행렬과-전치행렬-inverse-and-transpose&quot;&gt;2.2.2 역행렬과 전치행렬 (Inverse and Transpose)&lt;/h3&gt;
&lt;p&gt;행렬 A의 역행렬이 존재하는 경우 regular/invertible/nonsingular라고 부름. &lt;br /&gt;
역행렬이 존재하면 고유(unique)하다.&lt;/p&gt;

&lt;p&gt;Theorem 증명&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;(Uniqueness of Inverse Matrix) If B and C are both inverses of an n × n matrix A, then B = C.&lt;/li&gt;
&lt;/ul&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;B = B I_n = B(A C) = (B A)C =I_nC = C.&lt;/script&gt;

&lt;p&gt;결합 법칙을 이용해서 증명이 가능하다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;If &lt;script type=&quot;math/tex&quot;&gt;AB = I&lt;/script&gt; then &lt;script type=&quot;math/tex&quot;&gt;BA = I&lt;/script&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A, B를 n 정사각행렬이라 하고 n-dimensional 벡터 공간을 정의하면 AB의 range는 full space. 따라서 B의 range도 dimension n이다. &lt;br /&gt;
&lt;script type=&quot;math/tex&quot;&gt;𝐵=𝐵𝐼=𝐵(𝐴𝐵)=(𝐵𝐴)𝐵&lt;/script&gt;. By the distributive law, &lt;script type=&quot;math/tex&quot;&gt;(𝐼−𝐵𝐴)𝐵=0&lt;/script&gt;. B는 full range이므로 I-BA가 영행렬이 되어야 한다. 따라서 I = BA.&lt;/p&gt;

&lt;p&gt;=&amp;gt; full rank이면 invertible하다. &lt;a href=&quot;https://sharmaeklavya2.github.io/theoremdep/nodes/linear-algebra/matrices/full-rank-inv.html&quot;&gt;증명&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;이외에도 augmented matrix를 Gaussian eliminiation을 통해서 Row-Echelon Form으로 변환한 뒤 연랍 일차 방정식을 푸는 방법에 대해서 공부하였다.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Park Seung Joon</name>
        
        
      </author>

      

      
        <category term="linear-algebra" />
      
        <category term="math" />
      

      
        <summary type="html">서울대 데이터사이언스대학원 Bootcamp를 수강하면서 배운 내용을 정리해보고자 한다. 1주차에는 데이터사이언스를 위한 수학을 주제로 오민환 교수님께서 강의를 진행했다. 교재는 Mathematics for Machine Learning이라는 오픈 소스 교재를 사용하였다. 오늘은 Ch2까지 배운 선형대수의 기초적인 내용을 정리해본다.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">4. Subspace</title>
      <link href="https://soonjune.github.io/Subspace" rel="alternate" type="text/html" title="4. Subspace" />
      <published>2020-10-10T22:00:00+09:00</published>
      <updated>2020-10-10T22:00:00+09:00</updated>
      <id>https://soonjune.github.io/Subspace</id>
      <content type="html" xml:base="https://soonjune.github.io/Subspace">&lt;p&gt;오늘은 mit Gilbert Strang 선생님의 선형대수 Subspace에 관한 부분을 정리해 보았다.&lt;/p&gt;

&lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML&quot;&gt;
&lt;/script&gt;

&lt;h3 id=&quot;i-4-fundamental-subspaces&quot;&gt;I. 4 Fundamental Subspaces&lt;/h3&gt;
&lt;p&gt;A is m x n&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;columnspace C(A) in &lt;script type=&quot;math/tex&quot;&gt;R^m&lt;/script&gt;  &lt;br /&gt;
dimension of C(A) = # of pivot columns = rank r&lt;/li&gt;
  &lt;li&gt;nullspace N(A) in &lt;script type=&quot;math/tex&quot;&gt;R^n&lt;/script&gt;  &lt;br /&gt;
dimension of N(A) = # of free variables = n - r&lt;/li&gt;
  &lt;li&gt;rowspace = all combs of rows = all combs of columns = &lt;script type=&quot;math/tex&quot;&gt;A^T = C(A^T)&lt;/script&gt;  &lt;br /&gt;
same dimension as columnspace&lt;/li&gt;
  &lt;li&gt;nullspace of &lt;script type=&quot;math/tex&quot;&gt;A^T&lt;/script&gt; N(&lt;script type=&quot;math/tex&quot;&gt;A^T&lt;/script&gt;) = left nullspace of A &lt;br /&gt;
dimension = m - r
left nullspace라는 이름은 row벡터로 만들면 왼쪽에 오기 때문 (&lt;script type=&quot;math/tex&quot;&gt;y^TA = O&lt;/script&gt;)&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;ii-orthogonal-vectors-and-subspaces&quot;&gt;II. Orthogonal Vectors and Subspaces&lt;/h3&gt;
&lt;p&gt;1) Test for orthogonality: dot product is zero(&lt;script type=&quot;math/tex&quot;&gt;X^Ty = 0&lt;/script&gt;) &lt;br /&gt;
orthogonal한 벡터 간에는 피타고라스 정리가 성립한다. &lt;br /&gt;
&lt;script type=&quot;math/tex&quot;&gt;X^TX + Y^TY = (X+Y)^T(X+Y)&lt;/script&gt; &lt;br /&gt;
2) Subspace S와 T가 orthogonal하다는 것의 의미 &lt;br /&gt;
S에 속한 모든 벡터가 T에 속한 모든 벡터와 orthogonal하다. &lt;br /&gt;
=&amp;gt; Rowspace is Orthogonal to nullspace - 이유
&lt;script type=&quot;math/tex&quot;&gt;Ax = O&lt;/script&gt; &lt;br /&gt;
=&amp;gt; Rowspace and Nullspace are orthogonal complements in &lt;script type=&quot;math/tex&quot;&gt;R^n&lt;/script&gt; // 둘의 dimension을 더하면 n 
Nullspace contains all vectors perpendicular to rowspace&lt;/p&gt;

&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;Ax = b&lt;/script&gt; =&amp;gt; 양쪽변에 &lt;script type=&quot;math/tex&quot;&gt;A^T&lt;/script&gt;를 곱해준다.
How to “solve” the equation when there is no solution?  &lt;br /&gt;
m &amp;gt; n&lt;br /&gt;
실생활에서 noise 때문에 A를 제대로 알 수 없는 경우 - noise를 제거해야.&lt;br /&gt;
&lt;script type=&quot;math/tex&quot;&gt;A^TA&lt;/script&gt;: square, symmetric, invertible?
&lt;script type=&quot;math/tex&quot;&gt;N(A^TA) = N(A)&lt;/script&gt; &lt;br /&gt;
rank of &lt;script type=&quot;math/tex&quot;&gt;A^TA&lt;/script&gt; = rank of A &lt;br /&gt;
&lt;script type=&quot;math/tex&quot;&gt;A^TA&lt;/script&gt; is invertible exactly if A has independent columns&lt;/p&gt;

&lt;h3 id=&quot;iii-projections-onto-subspaces&quot;&gt;III. Projections onto Subspaces&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;Projection Matrix (P) &lt;br /&gt;
projp = Pb   P = &lt;script type=&quot;math/tex&quot;&gt;(aa^T) / (a^Ta)&lt;/script&gt; &lt;br /&gt;
columnspace of C(P) = line through a &lt;br /&gt;
rank(P) = 1 &lt;br /&gt;
    &lt;ul&gt;
      &lt;li&gt;P is symmetric&lt;/li&gt;
      &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;P^2 = P&lt;/script&gt; &lt;br /&gt;
Projection이 필요한 이유? Ax=b의 해가 없을 수도 있어서
가장 비슷한 문제를 푼다. =&amp;gt; Solve Ax = p(proj of b onto columnspace)
Key: b-Ax is perpendicular to plane
&lt;script type=&quot;math/tex&quot;&gt;(a_1)^T(b-Ax)=0, (a_2)^T(b-Ax)=0&lt;/script&gt;&lt;br /&gt;
&lt;script type=&quot;math/tex&quot;&gt;A^T(b-Ax) = O&lt;/script&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;What subsapce is error vector e(b-Ax) in?&lt;br /&gt;
e is in &lt;script type=&quot;math/tex&quot;&gt;N(A^T)&lt;/script&gt;  =&amp;gt;
e is perpendicular to C(A) &lt;br /&gt;
&lt;script type=&quot;math/tex&quot;&gt;A^TAx = A^Tb&lt;/script&gt; &lt;br /&gt;
&lt;script type=&quot;math/tex&quot;&gt;x = (A^TA)^(-1)A^Tb&lt;/script&gt;
P = Ax = A(A^TA)^(-1)A^Tb&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;script type=&quot;math/tex; mode=display&quot;&gt;P^T = P&lt;/script&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;P^2 = P&lt;/script&gt; &lt;br /&gt;
Application: Least squares fitting by a line &lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;</content>

      
      
      
      
      

      <author>
          <name>Park Seung Joon</name>
        
        
      </author>

      

      
        <category term="linear-algebra" />
      
        <category term="math" />
      

      
        <summary type="html">오늘은 mit Gilbert Strang 선생님의 선형대수 Subspace에 관한 부분을 정리해 보았다.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">3. Determinant</title>
      <link href="https://soonjune.github.io/Determinants" rel="alternate" type="text/html" title="3. Determinant" />
      <published>2020-10-04T22:00:00+09:00</published>
      <updated>2020-10-04T22:00:00+09:00</updated>
      <id>https://soonjune.github.io/Determinants</id>
      <content type="html" xml:base="https://soonjune.github.io/Determinants">&lt;p&gt;오랜만에 선형대수 정리를 다시 시작한다. 오늘은 판별식(Determinant)에 대해 알아보자.
판별식은 고유값(eigenvalue)을 구하기 위해 필요한 식 중 하나다.
유명한 &lt;a href=&quot;https://www.youtube.com/watch?v=srxexLishgY&quot;&gt;Gilbert Strang 선생님의 MIT 강의&lt;/a&gt;를 나만의 말로 정리해 보았다.&lt;/p&gt;

&lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML&quot;&gt;
&lt;/script&gt;

&lt;h3 id=&quot;판별식의-성질&quot;&gt;판별식의 성질&lt;/h3&gt;
&lt;p&gt;1) det I = 1 &lt;br /&gt;
2) 두 행을 바꾼 행렬의 판별식은 부호가 반대다. &lt;br /&gt;
3a) 한 행에 t를 곱하면 전체에 본래 판별식에 t를 곱한 것과 같다. &lt;br /&gt;
3b) 한 행에만 임의 값을 더해주면 본래 판별식에 더해주는 값을 분리한 행렬(나머지 행의 값은 동일)의 판별식의 합과 같다. &lt;br /&gt;
Determinant is Linear Each Row &lt;br /&gt;
4) 두 행의 값이 같으면 =&amp;gt; 판별식은 0이다.(2로부터 유도) &lt;br /&gt;
5) 한 행을 곱해서 다른 행에서 빼도 판별식이 달라지지 않는다.(3b, 3a, 4로부터 유도) &lt;br /&gt;
6) 한 행의 원소가 모두 0이라면 판별식도 0이다.(3a 또는 3b로 유도) &lt;br /&gt;
7) 삼각행렬의 판별식은 대각선에 위치한 원소들의 곱이다. (소프트웨어에서 판별식을 구하는 방식 -&amp;gt; 삼각행렬도 만들어서 대각선 곱한다. 3a를 이용해서 행마다 factor out하면 대각선 곱과 1이 남는다.)&lt;br /&gt;
8) 행렬의 역행렬이 존재하지 않으면 판별식은 0이다. &lt;br /&gt;
9) det AB = (det A) * (det B) &lt;br /&gt;
10) &lt;script type=&quot;math/tex&quot;&gt;detA^T = detA&lt;/script&gt; =&amp;gt; 열이 다 0이어도 판별식은 0이다를 보일 수 있다. (증명은 &lt;script type=&quot;math/tex&quot;&gt;|U^T||L^T| = |L||U|&lt;/script&gt; 보임으로써 할 수 있다.) &lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;판별식-공식&quot;&gt;판별식 공식&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://wikimedia.org/api/rest_v1/media/math/render/svg/b5300123cfe333f7a1e78d8dab5eb044d0be1548&quot; /&gt;
소행렬식(Minor) &lt;script type=&quot;math/tex&quot;&gt;M_(ij)&lt;/script&gt;는 i행과 j열을 제외한 행렬식이다.
아래서 보듯, cofactor는 i+j가 짝수이면 양수 i+j가 홀수이면 음수를 앞에 곱한다.
&lt;img src=&quot;https://wikimedia.org/api/rest_v1/media/math/render/svg/279a8d3f0f8f1338b8d2a4f80f1323f514edf60d&quot; /&gt;
&lt;img src=&quot;https://wikimedia.org/api/rest_v1/media/math/render/svg/089ce40623558856f6cd09a7c0dc23fded7d1e08&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;cofactor를-이용한-역행렬-구하기&quot;&gt;Cofactor를 이용한 역행렬 구하기&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://wikimedia.org/api/rest_v1/media/math/render/svg/0651000d4523a0563cd016ae064f75011e0d8702&quot; /&gt;
&lt;img src=&quot;https://wikimedia.org/api/rest_v1/media/math/render/svg/5b076e517a662a54fe32bfcd7ca2ec8a1998b139&quot; /&gt;
&lt;script type=&quot;math/tex&quot;&gt;AC^T = (detA)I&lt;/script&gt;임을 보이면 된다. 행렬곱의 대각선은 detA가 되고 나머지는 0이 된다는 것을 알 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;cramers-rule&quot;&gt;Cramer’s Rule&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://wikimedia.org/api/rest_v1/media/math/render/svg/4b063cb0d9acc0aed7f58ad881d845a2e2598e7f&quot; /&gt;&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Park Seung Joon</name>
        
        
      </author>

      

      
        <category term="linear-algebra" />
      
        <category term="math" />
      

      
        <summary type="html">오랜만에 선형대수 정리를 다시 시작한다. 오늘은 판별식(Determinant)에 대해 알아보자. 판별식은 고유값(eigenvalue)을 구하기 위해 필요한 식 중 하나다. 유명한 Gilbert Strang 선생님의 MIT 강의를 나만의 말로 정리해 보았다.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Pythonic Thinking(4) 파이썬 효율적으로 사용하기</title>
      <link href="https://soonjune.github.io/Effective-Python1_4" rel="alternate" type="text/html" title="Pythonic Thinking(4) 파이썬 효율적으로 사용하기" />
      <published>2020-09-01T23:30:00+09:00</published>
      <updated>2020-09-01T23:30:00+09:00</updated>
      <id>https://soonjune.github.io/Effective-Python1_4</id>
      <content type="html" xml:base="https://soonjune.github.io/Effective-Python1_4">&lt;p&gt;첫번째 챕터 Pythonic Thinking의 10번 팁을 간단하게 요약해보자. 개학도 해서 일찍 자야하고 10번 팁이 긴 편이라 하나만 정리하자.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;할당(Assignment; =) 표현으로 인한 반복을 피해라 (Python 3.8)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;아직 개발중인 Python 3.8의 walrus(바다코끼리) 연산자에 대한 내용이다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;walrus 연산자(:=)를 사용해서 존재하지 않는 변수에 대하여 할당과 동시에 사용이 한줄로 가능하다.&lt;/li&gt;
  &lt;li&gt;변수 할당이 다른 큰 표현 안에서 이루어지는 경우(예 if문에서의 대소 비교)에는 괄호&lt;code class=&quot;highlighter-rouge&quot;&gt;()&lt;/code&gt;를 안에 넣어주자.&lt;/li&gt;
  &lt;li&gt;파이썬에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;switch/case&lt;/code&gt;문과 &lt;code class=&quot;highlighter-rouge&quot;&gt;do/while&lt;/code&gt; 반복문이 존재하지 않지만 앞서 말한 walrus 연산자를 활용하면 간결하게 표현이 가능하다. (아래 예시 참조)
    &lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# 재료(과일 딕셔너리로 존재)가 허락하는 가장 좋은 주스를 갖는 경우 switch/case 문&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fresh_fruit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'banana'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;c&quot;&gt;# 바나나는 잘라야 된다.&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;pieces&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;slice_bananas&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;to_enjoy&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;make_smoothies&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pieces&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;elif&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fresh_fruit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'apple'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;to_enjoy&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;make_cider&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;elif&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fresh_fruit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'apple'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;to_enjoy&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;make_lemonade&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;to_enjoy&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'Nothing'&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# 모든 재료를 소진하여 주스 병을 만드는 경우 do/while 문&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;bottles&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fresh_fruit&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pick_fruit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fruit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fresh_fruit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;items&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;batch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;make_juice&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fruit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;bottles&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;extend&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;batch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;출처: Slatkin, B. (2020). Effective Python: 90 specific ways to write better Python. USA: Addison-Wesley.&lt;/em&gt;&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Park Seung Joon</name>
        
        
      </author>

      

      
        <category term="python" />
      

      
        <summary type="html">첫번째 챕터 Pythonic Thinking의 10번 팁을 간단하게 요약해보자. 개학도 해서 일찍 자야하고 10번 팁이 긴 편이라 하나만 정리하자.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">부자되기 도서 2개 소개</title>
      <link href="https://soonjune.github.io/how-to-become-rich" rel="alternate" type="text/html" title="부자되기 도서 2개 소개" />
      <published>2020-08-31T23:30:00+09:00</published>
      <updated>2020-08-31T23:30:00+09:00</updated>
      <id>https://soonjune.github.io/how-to-become-rich</id>
      <content type="html" xml:base="https://soonjune.github.io/how-to-become-rich">&lt;p&gt;이번 방학기간 동안 읽은 부자학(?) 관련 서적 2개를 소개하고자 한다.&lt;/p&gt;

&lt;h3 id=&quot;how-to-get-rich-one-of-the-worlds-greatest-entrepreneurs-shares-his-secrets&quot;&gt;&lt;a href=&quot;https://www.goodreads.com/book/show/1837402.How_to_Get_Rich&quot;&gt;How to Get Rich: One of the World’s Greatest Entrepreneurs Shares His Secrets&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;세계적인 잡지 맥심의 설립자인 Felix Dennis의 전기적인 책이다. 부자가 되는 법을 자세히 소개하고 있는데 맨 마지막 엑기스만 소개한다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;너의 필요를 분석하라. 욕구로는 부족하다. 충동은 필수적이다.&lt;/li&gt;
  &lt;li&gt;부정적인 영향을 미치는 것들로부터 벗어나라. 포기하지 마라. 목표를 향해 나아가라.&lt;/li&gt;
  &lt;li&gt;“대단한 아이디어”는 무시해라. 행동이 중요하다.&lt;/li&gt;
  &lt;li&gt;집중해라. 돈은 도처에 널려있다.&lt;/li&gt;
  &lt;li&gt;너보다 똑똑한 사람에게 일을 위임해라. 성과를 공유해라.&lt;/li&gt;
  &lt;li&gt;소유권은 비밀 비법이다. (회사를) 소유할 수 있을만큼 소유해라.&lt;/li&gt;
  &lt;li&gt;(회사를) 팔아야할 때가 오기 전 또는 재미가 없어지면 팔아라. 협상을 할 때에는 머리를 비워라.&lt;/li&gt;
  &lt;li&gt;아무것도 두려워 하지 마라. 부자가 돼라. 베풀어라.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;위 내용을 저자의 경험을 기반으로 주장한다. 또 다른 책은 위와는 맥락이 조금 다르다.&lt;/p&gt;

&lt;h3 id=&quot;이웃집-백만장자-변하지-않는-부의-법칙--흔들리지-않는-부는-어떻게-축적되는가&quot;&gt;이웃집 백만장자 변하지 않는 부의 법칙 : 흔들리지 않는 부는 어떻게 축적되는가&lt;/h3&gt;
&lt;p&gt;위 아버지 대부터 부자들을 연구해온 토머스 스탠리 박사가 통계를 기반으로 부자에 관한 내용을 설명한다.
부를 축적하는 자들과 그렇지 못한 두 부류로 나누어 설명하고 있다. 상세한 내용은 &lt;a href=&quot;https://en.wikipedia.org/wiki/The_Millionaire_Next_Door&quot;&gt;위키백과&lt;/a&gt;에도 있으니 참조하면 된다.&lt;/p&gt;

&lt;p&gt;다만, 앞서 소개한 책과의 차이를 저축과 근검함을 강조하고 있다는 것에서 볼 수 있다. 부자가 되는 것에 답은 없지만 결국 돈이라는 것도 행복해지기 위한 수단임을 명심하자.&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Park Seung Joon</name>
        
        
      </author>

      

      
        <category term="book-review" />
      

      
        <summary type="html">이번 방학기간 동안 읽은 부자학(?) 관련 서적 2개를 소개하고자 한다.</summary>
      

      
      
    </entry>
  
    <entry>
      <title type="html">Pythonic Thinking(3) 파이썬 효율적으로 사용하기</title>
      <link href="https://soonjune.github.io/Effective-Python1_3" rel="alternate" type="text/html" title="Pythonic Thinking(3) 파이썬 효율적으로 사용하기" />
      <published>2020-08-30T23:30:00+09:00</published>
      <updated>2020-08-30T23:30:00+09:00</updated>
      <id>https://soonjune.github.io/Effective-Python1_3</id>
      <content type="html" xml:base="https://soonjune.github.io/Effective-Python1_3">&lt;p&gt;첫번째 챕터 Pythonic Thinking의 7-9번 팁을 간단하게 요약해보자.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Range 대신 &lt;code class=&quot;highlighter-rouge&quot;&gt;Enumerate&lt;/code&gt;를 쓰자.
    &lt;ul&gt;
      &lt;li&gt;간결하게 iterator와 index를 이용할 수 있다.&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;range&lt;/code&gt;를 이용해서 loop를 돌면서 indexing을 하기보다 &lt;code class=&quot;highlighter-rouge&quot;&gt;enumerate&lt;/code&gt;를 사용하자.&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;enumerate&lt;/code&gt;의 두번째 파라미터를 이용해서 0 이외의 숫자부터 indexing할 수 있다. 아래 예시
        &lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;flavor&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;enumerate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;flavor_list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'{i}: {flavor}'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Iterator들을 병렬적으로 처리하기 위해 &lt;code class=&quot;highlighter-rouge&quot;&gt;zip&lt;/code&gt;을 사용하자.
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;enumerate&lt;/code&gt;와 마찬가지로 &lt;code class=&quot;highlighter-rouge&quot;&gt;zip&lt;/code&gt;이라는 기본 함수를 사용해서 여러 iterator들을 병렬적으로 처리할 수 있다.&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;zip&lt;/code&gt;은 iterator의 다음 값에 해당하는 값들을 tuple의 형태로 그때 그때 하나씩 생성한다(lazy generator). 따라서 메모리 걱정 없이 무한정 긴 iterator를 처리할 수 있다.&lt;/li&gt;
      &lt;li&gt;비교하는 두 iterator의 길이가 다르면 작은 쪽까지만 tuple을 생성하고 멈춘다.&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;itertools&lt;/code&gt; 모듈의 &lt;code class=&quot;highlighter-rouge&quot;&gt;zip_longest&lt;/code&gt;를 사용하면 길이가 긴 iterator에 맞춰서 tuple을 생성할 수 있다(짧은 쪽의 값엔 None이 default로 들어간다).&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;for&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;while&lt;/code&gt;문 다음에는 &lt;code class=&quot;highlighter-rouge&quot;&gt;else&lt;/code&gt; 사용을 지양하자.
    &lt;ul&gt;
      &lt;li&gt;for나 while문 뒤에 else가 오게되면 어떻게 되는지 알자.&lt;/li&gt;
      &lt;li&gt;break를 사용하게 되면 뒤에 else가 실행되지 않는다.&lt;/li&gt;
      &lt;li&gt;따라서 헷갈리고 비직관적인 반복문 뒤 &lt;code class=&quot;highlighter-rouge&quot;&gt;else&lt;/code&gt; 사용을 지양하자.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;em&gt;출처: Slatkin, B. (2020). Effective Python: 90 specific ways to write better Python. USA: Addison-Wesley.&lt;/em&gt;&lt;/p&gt;</content>

      
      
      
      
      

      <author>
          <name>Park Seung Joon</name>
        
        
      </author>

      

      
        <category term="python" />
      

      
        <summary type="html">첫번째 챕터 Pythonic Thinking의 7-9번 팁을 간단하게 요약해보자.</summary>
      

      
      
    </entry>
  
</feed>
